## 01 - 面向对象的高级编程

---

### 1. 头文件与类的声明

针对头文件`complex.h`的结构，主要可以分为以下四个部分：

```cpp
#ifndef __MYCOMPLEX__
#define __MYCOMPLEX__

#include <cmath>

class ostream;
class complex;

complex&
__doapl (complex* ths, const complex& r);

class complex {
 ...
}

complex::function ...

# endif
```

1. **防卫式声明**：通过`#ifndef`、`#define`、`#endif`防止头文件被重复包含

```cpp
#ifndef __MYCOMPLEX__
#define __MYCOMPLEX__

...

# endif
```

- 优先包含标准库头文件
- 按依赖顺序声明自定义类型
- 避免不必要的包含，减少编译依赖
- 推荐使用全大写命名格式，例如：PROJECTNAME_MODULENAME_FILENAME_H
- 现代C++可使用`#pragma once`替代（编译器扩展，非标准但广泛支持），编译器在识别到#pragma once后直接跳过后续内容，比传统宏防卫（需扫描到#endif）更快。

```Cpp
#pragma once
#ifndef MY_HEADER_H
#define MY_HEADER_H
// 头文件内容...
#endif
```

**与#ifndef宏的对比**

| **特性**             | **pragma once**          | **ifndef宏防卫**             |
|:---------------- |:-------------------- |:------------------------ |
| 标准支持         | 非标准，但主流支持   | 符合C/C++标准            |
| 使用复杂度       | 一行代码             | 需定义唯一宏名，三行代码 |
| 编译速度         | 更快（提前终止解析） | 较慢（需扫描到#endif）   |
| 跨平台稳定性     | 依赖编译器支持       | 所有编译器通用           |
| 处理相同内容文件 | 无法解决             | 宏名唯一即可解决         |

**兼容性**

| 编译器类型                | 行为                                    |
|----------------------|---------------------------------------|
| 支持#pragma once的编译器   | 直接跳过后续重复包含，无需处理#ifndef逻辑，提升编译速度       |
| 不支持#pragma once的旧编译器 | 忽略#pragma once，继续执行#ifndef宏防卫逻辑，保证兼容性 |


2. **前置声明**: 提前声明头文件中用到的类和函数，为后续代码准备好依赖关系

```cpp
#include <cmath>

class ostream;
class complex;

complex&
__doapl (complex* ths, const complex& r);
```

3. **类声明**: 在类声明中定义类的函数和变量，并可以实现一些简单的函数

```cpp
class complex {
 ...
}
```

4. **类定义**: 实现前面声明的函数，在这里完成类成员函数的具体实现

```Cpp
complex::function ...
```

### 2. 构造函数

#### 2.1. 访问级别

在C++中，共有三种访问级别，这段程序展示了其中的两种:

| **访问级别** |            **意义**            |
| ------------ |:------------------------------:|
| private      |      只能被**本类的函数**访问      |
| protected    | 能被**本类的函数**和**子类的函数**访问 |
| public       |       可以被所有函数访问       |

将数据成员放在private声明下，提供接口函数访问数据，从而保证数据的安全性:

```Cpp
class complex {
    public:
        complex(double r = 0, double i = 0):
            re(r), im(i) {}
        complex &operator+=(const complex &);
        double real() const { return re; }
        double imag() const { return im; }

    private:
        double re, im;
        friend complex &__doapl(complex*, const complex &);
};
```

![](/images/C&C++/Pasted%20image%2020250220121002.png)

#### 2.2. 内联函数

在类声明内定义的函数会自动成为`inline`函数；在类声明外定义的函数需要显式加上`inline`关键字才能成为`inline`函数

|      **类声明内定义的函数,自动成为`inline`函数**      | **类声明外定义的函数需在定义时加上`inline`关键字才能成为`inline`函数** |
|:-----------------------------------------------------:|:-----------------------------------------------------------------:|
| ![](/images/C&C++/Pasted%20image%2020250220120142.png) |       ![](/images/C&C++/Pasted%20image%2020250220120332.png)       |

`inline`只是编程者给编译器的一个建议，在编译时未必会真正被编译为`inline`函数。因此如果函数足够简单，我们就把它声明为`inline`就行

#### 2.3. 构造函数

构造函数可以使用默认实参和成员**初始化列表**。而在构造函数体内的赋值和在初始化列表中的初始化是不同的

![](/images/C&C++/Pasted%20image%2020250220121127.png)

**在初始值列表中，才是初始化**。在构造函数体内的，叫做赋值。上面两种构造函数的效果是一样的，但是使用列表初始化的效率更高，应尽量使用列表初始化。

```Cpp
// 推荐写法（初始化列表）
complex(double r = 0, double i = 0) : re(r), im(i) {}

// 不推荐写法（函数体内赋值）
complex(double r = 0, double i = 0) { re = r; im = i; }
```

默认实参使得类的使用者更灵活地创建对象：

```Cpp
complex c1;          // 等效于complex(0, 0)
complex c2(5);       // 等效于complex(5, 0)
complex c3(2, 1);    // 标准构造
complex* p = new complex(4);  // 动态分配
```

#### 2.4. 函数重载

构造函数的重载应避免歧义。使用默认实参时应注意，避免编译器出现歧义导致的编译失败，以免导致使用者在创建对象时遇到错误：

![](/images/C&C++/Pasted%20image%2020250220121634.png)

```Cpp
complex c1(2, 1);	// 这一行编译通过
complex c2;			// 这一行编译失败: error: call of overloaded 'complex()' is ambiguous
```

### 3. 参数传递与返回值

#### 3.1. 常量成员函数

**对于不改变类属性（数据成员）的成员函数，务必加上 `const` 声明。**

```Cpp
double real () const {return re;}  
double imag() const {return im;}
```

通过在函数后加上 `const`，我们明确表示这个函数不会修改对象的状态。这一声明不仅能够帮助编译器进行更好的优化，也能让阅读代码的人员更清楚地理解函数的意图。此外，只有 `const` 对象才能调用这些带有 `const` 修饰符的成员函数——即 `const` 对象无法调用非 `const` 的成员函数。

如果这类函数不添加 `const` 修饰，常量对象将无法调用这些函数:

![](/images/C&C++/Pasted%20image%2020250220203900.png)

#### 3.2. 参数的值传递和引用传递

函数的参数尽量使用引用传递，这样可以避免参数的复制。同时，使用 `const` 可以确保这些参数在函数内部不会被意外修改。对于内置类型，值传递与引用传递的效率差别并不显著，甚至在某些情况下，值传递可能更高效。例如，传递 `char` 类型时，值传递仅需传递一个字节；**而使用引用传递时实际上需要传递一个指针，这在 32 位机上需要四个字节的开销**。然而，为了保持代码的一致性，建议统一使用引用传递。

![](/images/C&C++/Pasted%20image%2020250220204826.png)

#### 3.3. 返回值的值传递和引用传递

![](/images/C&C++/Pasted%20image%2020250220205139.png)

为了提高效率，如果**函数的返回值是一个已经存在的对象**，应该以引用的形式返回。**对于临时变量，返回值只能通过值传递**。

以 `operator+=` 为例，它的返回值是引用，因为在执行 `a += b` 时，`a` **已经在内存中存在**。相比之下，`operator+` 不能以引用的形式返回，因为 `a + b` 的结果是在调用 `operator+` 时**才会产生的临时值**。返回这个临时值的引用将导致不确定的行为，因为该临时对象在函数返回后会被销毁。

```cpp
inline complex & complex :: operator += (const complex & r)  
{  
        this -> re+= r->re;  
        this -> im+= r->im;  
        return * this;  
}  
inline complex operator + (const complex & x , const complex & y)  
{  
        return complex ( real (x)+ real (y),                        //新创建的对象，不能返回引用  
                                 imag(x)+ imag(y));  
}
```

在 `operator+=` 中返回引用是必需的，这样可以支持链式操作。例如：

```Cpp
a += b += c; 
```

在这个表达式中，首先计算 `b += c`，然后将其结果直接用于更新 `a`。由于 `operator+=` 返回的是对 `a` 的引用，这样的设计便于连续的操作，提升了代码的简洁性和可读性。如果 `operator+=` 返回的是值而不是引用，就无法进行链式调用。

#### 3.4. 友元函数

**友元函数不受访问控制的限制，可以自由访问类中所有成员，包括私有成员和保护成员**。即使函数不属于类的成员，其依然能够访问该类的私有数据。尽管友元函数能够访问类的私有成员，但这通常会打破封装性，因此在使用友元函数时应谨慎。

![](/images/C&C++/Pasted%20image%2020250220205803.png)

**同一类的各个对象互为友元**，则类定义里可以**自由访问彼此的私有成员变 量和保护成**员

![](/images/C&C++/Pasted%20image%2020250220210148.png)

```Cpp
complex c1, c2;
c2.func(c1);		// 因为c1和c2互为友元,因此c2可以在func()函数内调用c1的私有变量
```

### 4. 操作符重载

在C++中，操作符重载可以通过两种方式实现：一种是在**类内定义公共成员函数**以重载操作符，这样操作符将作用于左操作数；另一种是在**类外定义全局函数**进行重载。

以下是关于如何重载操作符“+”的示例：

```Cpp
complex c1;
c1 + 2;  // 需要重载操作符“+”
```

我们可以通过两种方式来实现操作符的重载：

1.  在类内声明公共成员函数，形式为 `complex::operator+= (int)`。
2.  在类外声明全局函数，形式为 `complex operator+ (const complex&, double)`。

这两种方法都可以实现操作符的重载。

#### 4.1. 类内声明 public 函数重载 +=

在重载 `+=` 运算符的 `complex::operator+= (const complex& r)` 函数中，输入参数和输出参数均采用**传引用**的形式。为了确保输入参数在函数内部不被修改，我们使用 `const` 关键字进行修饰。

输出参数的类型为 `complex&`，这是为了支持多个 `+=` 操作的链式调用。如果将返回类型设定为 `void`，虽然仍然可以执行形式为 `c2 += c1` 的运算，但将无法实现如 `c3 += c2 += c1` 的链式运算，因此这种设计可以提升操作的灵活性与表达能力。

![](/images/C&C++/Pasted%20image%2020250220212245.png)

在函数体内，我们调用了友元函数 `__doapl(complex *, const complex &)` 来实现具体的功能。该函数的第一个参数接收成员函数中隐含的 `this` 指针，**该指针所指向的内容可能会在函数内部被修改（即+=的左边）**。第二个参数则接收重载函数的参数，并且使用 `const` 关键字进行修饰，以确保在函数内部该参数不会被修改。

这个例子清楚地表明了使用引用传递参数和返回值所带来的优势。**传送者无需关心接收者是以引用形式接收参数，还是以值传递的方式进行处理**。传送者只需像使用值传递那样编写代码，不必做任何修改。**任何成员函数都有一个隐藏的 this pointer**。

![](/images/C&C++/Pasted%20image%2020250220212408.png)

#### 4.2. 在类外声明或函数重载+

在重载运算符时，我们需要考虑是否支持多种不同的用法。在我们的复数类中，运算符 `+` 可能会有多种应用方式，例如：

```Cpp
complex c1(2, 1);
complex c2;

c2 = c1 + c2;    // 用法1: complex + complex
c2 = c1 + 5;     // 用法2: complex + double
c2 = 7 + c1;     // 用法3: double + complex
```

由于运算符重载的成员函数是作用于左操作数的，因此，如果我们将类内运算符声明为 `public` 成员函数的方式，就无法支持第三种用法。所以我们需要在**类外声明相应的重载函数**来适应这些不同的加法场景。为此，`+` 运算符需要提供以下三种重载形式：

```Cpp
inline complex operator+(const complex &x, const complex &y) {
    return complex(real(x) + real(y), 
				   imag(x) + imag(y));
}

inline complex operator+(const complex &x, double y) {
    return complex(real(x) + y, imag(x));
} 

inline complex operator+(double x, const complex &y) {
    return complex(x + real(y), imag(y));
}

```

这三个函数返回的是**局部对象（local object）**，在函数执行结束后，这些对象会被销毁。因此，使用**传引用**来返回这些值是不合适的，即**函数内的加法结果是个临时变量，在内存中并不存在，函数执行完毕后就销毁**。Typename () 小括号就是创建临时对象，右图黄色两个临时变量在赋值完毕后就销毁，所以无法调用。如果 double y 是一个**常量或临时值**，传引用可能会导致编译错误或未定义行为，所以**传值**。

![](/images/C&C++/Pasted%20image%2020250220213900.png)

函数重载是根据传入的参数类型和参数个数来区分不同的函数实现的，如下图所示：

![](/images/C&C++/Pasted%20image%2020250220214604.png)

因为**取正函数**并没有产生新的临时变量，故也可以使用传引用 `inline complex&` 的写法。

其他操作符重载：

![](/images/C&C++/Pasted%20image%2020250220220005.png)

![](/images/C&C++/Pasted%20image%2020250220215359.png)

#### 4.3. 在类外声明函数重载<<

与重载+操作符类似，<<操作符通常使用方式是 `cout << c1` 而不是 `c1 << cout`，因此**不能使用成员函数重载<<操作符**。考虑到类似 cout << c1 << c2 << c3 的级联用法，**重载函数的返回值应为 ostream& 而非 void**，即**传引用**。

![](/images/C&C++/Pasted%20image%2020250220215335.png)

**第一个参数 ostream& os 就是 cout，cout 是一个 ostream 对象**，不能加 const（即 operator << (const ostream& os, const complex& x)），因为 cout 的状态在每次执行后会发生改变。返回值是 ostream&，以便支持连续输出。**优先使用传引用**，且不加 const，也是因为 cout 的值会改变。

### 5. 编写类的注意事项

编写类时应注意以下五个要点，可以看出你写的代码是否大气：

1.  在构造函数中使用**初始化列表**为成员变量赋值：
2.  使用 **const** 修饰常量成员函数。
3.  **尽量使用引用传递参数**，在不修改参数的情况下应**添加 const 修饰**。
4.  若返回值**不是局部变量**，应尽量使用引用传递返回。
5.  将**数据放入 private 成员**中，将大部分**函数放入 public 成员**中。

### 6. Big Three：拷贝构造、拷贝赋值、析构

`String`类定义在头文件`string.h`中,其结构与`complex.h`类似

![](/images/C&C++/Pasted%20image%2020250221151031.png)

#### 6.1. 构造函数和析构函数

对于不带有指针的类，编译器会为我们自动生成默认的构造函数、拷贝构造函数和析构函数。但是**对于带有指针的类，特别是动态分配内存的情况，是有必要手动定义这三个特殊函数的**：

1.  **构造函数**：需要确保指针成员正确初始化，以避免悬空指针或内存泄漏的问题。
2.  **拷贝构造函数**：需要深拷贝指针指向的内容，以防止浅拷贝导致的多个对象指向同一内存地址，造成释放重复内存或释放无效内存的问题。
3.  **析构函数**：需要释放动态分配的内存，以防止内存泄漏。

```Cpp
int main() {
    String s1("hello");
    String s2("world");

    String s3(s2);        // 调用拷贝构造函数
    cout << s3 << endl;

    s3 = s1;              // 调用拷贝赋值函数
    String s4 = s1;       // 调用拷贝构造函数
    cout << s3 << endl;
    cout << s2 << endl;
    cout << s1 << endl;
}
```

类声明如下，使用指针成员变量`m_data`来管理`String`类中的字符串数据。

![](/images/C&C++/Pasted%20image%2020250221152145.png)

```cpp
class String {
    public:
		//Big Three
        String(const char* cstr = nullptr);                 // 默认构造函数，默认实参为 0
        String(const String &str);                          // 拷贝构造函数
        String &operator=(const String &str);               // 拷贝赋值函数
        ~String();                                          // 析构函数
	    
	    String(const String &str) = delete;                 // 删除拷贝构造函数
        String &operator=(const String &str) = delete;      // 删除拷贝赋值函数
        
        // 获取字符串，const 修饰成员函数，确保不会修改数据成员
        char* get_c_str() const {
            return m_data;
        }

    private:
        char* m_data;
};
```

使用指针 `m_data` 指向 `new` 分配的空间。在进行拷贝构造后，新创建的对象就包含了指向的内容。注意使用`delete[]`操作符释放动态分配的数组内存，而不是直接使用`delete`操作符。虽然直接使用`delete`操作符也可以通过编译，但可能会导致**内存泄漏**。函数离开作用域会调用三次析构函数

![](/images/C&C++/Pasted%20image%2020250221154041.png)

#### 6.2. 拷贝构造函数和拷贝赋值函数

**默认的拷贝构造函数**和**赋值构造函数**执行的是**浅拷贝**（Shallow Copy），即对对象的内存进行**逐位的复制**。在C++中，仅仅复制了对象的成员变量，包括指针本身，而**不会复制指针所指向的实际内容**。现在有两个`String`对象：

```cpp
String a("Hello");  
String b("World");
```

a、b在内存上如图所示：

![](/images/C&C++/Pasted%20image%2020250221160600.png)

如果此时执行：

```Cpp
b = a;
```

浅拷贝体现为：

![](/images/C&C++/Pasted%20image%2020250221160706.png)

存储 `World\0` 的内存块没有指针指向它，因此变成了无法访问的内存块，从而造成了**内存泄漏**。此外，如果此时对象a被删除，并且使用我们之前提到的析构函数释放了存储 `Hello\0` 的内存块，那么对象b中的`m_data`指针现在会变成悬空指针（dangling pointer）。悬空指针是指指向之前分配的内存，但此内存已经被释放的情况，使用悬空指针会导致未定义行为。

拷贝构造函数的实现较为简单，只需使用**友元对象的数据指针**进行**深拷贝**：

![](/images/C&C++/Pasted%20image%2020250221161131.png)

拷贝赋值函数时，需要检查是否为自我赋值。这不仅有助于提高效率，还可以避免出现潜在的 bug：

![](/images/C&C++/Pasted%20image%2020250221161722.png)

1. 释放之前分配的内存
2. 分配一个与目标字符串相同大小的内存块
3. 将字符串复制到新分配的内存中

对于`a = b`，1 2 3 过程如下：

|                         步骤1                         |                         步骤2                         |                         步骤3                         |
|:-----------------------------------------------------:|:-----------------------------------------------------:|:-----------------------------------------------------:|
| ![](/images/C&C++/Pasted%20image%2020250221162113.png) | ![](/images/C&C++/Pasted%20image%2020250221162126.png) | ![](/images/C&C++/Pasted%20image%2020250221162151.png) |

**注意**：**operator = 一定要检查是否存在自我赋值情况**。如果出现自我赋值，即左右操作数指向同一内存块，**那么在删除该内存块后对右操作数的内存访问将导致未定义行为**，即上图的 `s2 = s1`。

![](/images/C&C++/Pasted%20image%2020250221162242.png)

### 7. 堆栈与内存管理

#### 7.1. 堆栈及对象的生命周期

- **栈（stack）**：存在于某作用域 (scope) 的一块內存空间(memory space)。例如调用函数，函数本身即会形成一个栈用来放置它所接收的参数，以及返回地址。**在函数体 (function body) 內声明的任何变量，其所使用的內存块都取自上述栈**。
- **堆（Heap）**：指由操作系統提供的一块全局內存空间，程序可动态分配 (dynamic allocated) 从其中获得若干区块 (blocks)。

![](../../../images/C&C++/Pasted%20image%2020250221221104.png)

1. **stack object的生命周期**：

在C++中，栈对象（stack object）的生命周期与其所在的作用域紧密相关。以下代码展示了一个典型的使用示例：

```Cpp
class Complex { ... };
// ...
    
{
Complex c1(1,2);
}
```

在这个示例中，`c1` 是一个**栈对象**。它的生命周期从创建的那一刻开始，到其所在的作用域（由大括号 `{}` 界定）结束时终止。在这个作用域结束时，`c1` 会自动被清理，因此这种对象也被称为**自动对象（auto object）**。这种自动清理的机制有助于简化内存管理，避免内存泄漏。

2. **static object的生命周期**

```Cpp
class Complex { ... };
// ...

{
    static Complex c2(1, 2);
}
```

在这个程序中，`c2` 是一个**静态对象（static object）**。与栈对象不同，`c2` 的生命周期并不局限于其作用域（即大括号内）。即使作用域结束，`c2` 仍然存在，**直到整个程序结束时才会被销毁**。这种特性使得静态对象能够在多次函数调用之间保持其状态，是一种**全局性的存储机制**。

3. **global object的生命周期**

```cpp
class Complex { ... };
// ...

Complex c3(1, 2);

int main()
{
    ...
}
```

在这个程序中，`c3` 是一个**全局对象（global object）**，其生命周期延伸至整个程序的运行周期。**可以将全局对象视为一种静态对象（static object）**，其作用域涵盖整个程序。

4. **heap object的生命周期**

```cpp
class Complex { ... };
// ...

{
    Complex* p = new Complex;
    // ...
    delete p;
}
```

![](../../../images/C&C++/Pasted%20image%2020250221221948.png)

在这个程序中，`p` 指向的对象是堆对象（heap object）。堆对象的生命周期在调用 `delete` 释放它的内存时结束。如果在作用域结束时忘记释放 `p` 指向的堆对象，将会导致**内存泄漏**，即堆对象仍然存在，但无法再通过指针 `p` 访问它，因为指针 `p` 的生命周期已经结束，作用域外无法再操作 `p` 指向的堆对象。

#### 7.2. new 和 delete 过程中的内存分配

|             `new`操作**先分配内存，再调用构造函数**             |           `delete`操作**先调用析构函数，再释放内存**            |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222111332.png) | ![](../../../images/C&C++/Pasted%20image%2020250222111345.png) |

对于带有指针的`String`类,`new`操作和`delete`操作的示意图如下:

|                            **new**                             |                           **delete**                           |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222111456.png) | ![](../../../images/C&C++/Pasted%20image%2020250222111507.png) |

##### 7.2.1. 内存分配

C++分配内存和释放内存，实际上是**使用了 C 语言的 malloc 和 free 函数**。VC中对象在 `Debug` 模式和 `Release` 模式下的内存分布如下图所示。变量在内存中所占字节数必须被补齐为 16 的倍数。红色代表 Cookie 保存内存块的大小，其**最低位的 1 和 0 分别表示内存是否被回收**。`Debug` 模式下 Complex 对象绿色部分因为**算出的大小为52不是16的倍数**，因此需要额外的填充(padding)来补齐到64字节，以确保内存对齐和性能。64字节对应十六进制为`0x40`，而在cookie中表示为`41`，表示内存块已经**被分配**。

|                        **Complex对象**                         |                         **String对象**                         |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222113616.png) | ![](../../../images/C&C++/Pasted%20image%2020250222113634.png) |

##### 7.2.1. 数组分配

|                        **Complex对象**                         |                         **String对象**                         |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222114003.png) | ![](../../../images/C&C++/Pasted%20image%2020250222114136.png) |

在 C++ 中，**良好的编程习惯是严格匹配内存分配与释放的方式**，即使用 `new[]` 分配的内存必须用 `delete[]` 释放，而使用 `new` 分配的内存必须用 `delete` 释放，否则可能会导致未定义行为或内存泄漏。如果错误地使用 `delete` 释放通过 `new[]` 分配的内存，或者使用 `delete[]` 释放通过 `new` 分配的内存，程序对于数组对象，**部分元素的析构函数可能未被调用**。

![](../../../images/C&C++/Pasted%20image%2020250222114343.png)

### 8. static 成员

#### 8.1. 静态成员变量

在面向对象编程中，类的成员变量可以分为**静态**（`static`）和**非静态**两种类型。以银行账户类为例，每个用户可以拥有自己的银行账户，而**银行利率是银行类的一个属性，它不应该属于单个账户对象，而是应该由所有账户共享**。在这种情况下，我们可以将银行利率声明为静态成员变量。

**静态成员变量存储在程序的全局区中**，整个程序运行过程中**只有一份副本**。相比之下，**非静态成员变量则存在于每个对象的内存中**，每个对象都拥有自己的副本。如果将银行利率作为非静态成员变量，会导致每个账户对象都存储一份相同的利率数据，从而**造成内存浪费**。

![](../../../images/C&C++/Pasted%20image%2020250222151450.png)

例如，如果 `c1`, `c2`, `c3` 是非静态变量，则它们将在内存中各自有不同的内存空间和数据值。当将 `c1`, `c2`, `c3` 声明为静态变量时，只会创建一份内存空间并被所有引用这些静态变量的成员所共享。

#### 8.2. static 成员函数没有this指针

静态（static）成员函数与普通函数类似，都只存在一个函数副本，存储在进程的代码段中。不同之处在于，**静态成员函数不包含 this 指针**，因此无法访问普通成员变量，**只能访问静态成员变量**。普通成员函数需要通过对象调用，编译器会获取对象的地址，并将其作为 this 指针传递给成员函数。

与普通成员函数不同的是，静态成员函数既可以通过**对象调用**，也可以通过**类名称直接调用**。此外，**静态成员变量必须在类外部进行定义即初始化**。

```Cpp
class Account {
public:
    static double m_rate;     // 静态成员声明
    static void set_rate(const double& x) { m_rate = x; } 
};

double Account::m_rate = 8.0; // 静态成员初始化

int main() {
    Account::set_rate(5.0);   // 通过类名称调用
    Account a;
    a.set_rate(7.0);          // 通过对象调用
}
```

#### 8.3. static 类的应用：单例模式

在单例模式的实现中，**static成员函数**和**static成员变量**发挥着关键作用。以下是被称为 **饿汉式（Eager Initialization）** 的单例模式实现及其分析：

```Cpp
class A {
public:
    // 静态成员函数，提供全局访问点
    static A& getInstance() { return instance; }
    void doSomething() {
        // 示例方法
    }

private:
    A() {}                // 默认构造函数
    A(const A& rhs)       // 拷贝构造函数

    // 静态成员变量，存储唯一实例
    static A instance;
};

// 在类外定义并初始化静态成员变量
A A::instance;
```

这个例子中，将 class A 的**构造函数设为私有**，阻止用户代码直接创建对象，而是**通过 getInstance 接口获取对象实例**。然而，"饿汉式"的缺点在于**无论实例是否被需要，实例都会在程序启动时被创建出来**。

以下是一个改进的 **懒汉式（Lazy Initialization）** 单例模式的示例代码：

```Cpp
class A {
public:
    // 静态成员函数，提供全局访问点
    static A& getInstance() {}
    void doSomething() {
        // 示例方法
    }

private:
    A() {}                // 默认构造函数
    A(const A& rhs)       // 拷贝构造函数
};

// 在类外定义并初始化静态成员变量
A& A::getInstance() {
	static A instance;
	return A;
};
```

“懒汉式”只有在**真正需要实例时才会调用 getInstance 方法来创建唯一实例**。这种方式可以被看作是一种懒惰的实例化方法，也就是直到必要的时候才会进行实例化。很多设计模式都体现了这种懒惰思想，例如**字符串类的写时复制机制**，只有在需要时才为字符串对象分配内存。

### 9. 模板简介

|                           **类模板**                           |                          **函数模板**                          |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222155547.png) | ![](../../../images/C&C++/Pasted%20image%2020250222155655.png) |

- **类模板**：用来定义通用类的模板，通过模板参数来表示成员变量或成员函数中的数据类型。在实例化时，需要指定模板参数，生成具体的特定类型的类。**类模板可以包含成员变量和成员函数**，适用于需要**定义通用数据结构或算法**的场景。
- **函数模板**：定义通用函数的模板，通过模板参数来表示参数类型或返回类型。在调用时，**函数模板可以自动推导参数类型，无需显式指定**。函数模板适用于需要**实现通用算法或操作**的情况下。
  
值得注意的是，类模板和函数模板可以帮助避免为不同类型重复编写相似的代码，**提高了代码的复用性**，但也会使代码更复杂，不易阅读和理解，增加维护难度。此外，每个不同的类型实例化都会生成一份新的代码，可能导致二进制文件体积增大，即**代码膨胀**。

### 10. 组合与继承

#### 10.1. 复合

在面向对象编程中，**复合（Composition）** 表示的是一种“has-a”的关系，即**一个对象包含或拥有另一个对象**作为其组成部分。这种设计模式在标准模板库（STL）中得到了广泛应用，例如`std::queue`的实现。`std::queue`通过内部封装其他容器（如`std::deque`或`std::list`）来提供队列的功能，而不是直接继承这些容器，这种结构也被称为**适配器模式（Adapter Pattern）**。

![](../../../images/C&C++/Pasted%20image%2020250222165942.png)

适配器模式的核心思想是**通过将一个类的接口转换为另一个接口，来满足特定的需求**。在`std::queue`的例子中，它将底层容器（如`deque`或`list`）的**接口适配为队列的接口**（即更改函数名），从而提供先进先出（FIFO）的操作方式。这种方式不仅避免了直接继承带来的耦合问题，还使得`std::queue`能够灵活地选择底层容器，以满足不同的性能需求。

以下是从内存的角度分析：

![](../../../images/C&C++/Pasted%20image%2020250222170456.png)

在复合关系中，对象之间的生命周期管理遵循“**构造由内而外，析构由外而内**”的原则。这一原则是C++对象生命周期管理的重要机制，尤其在涉及资源管理和复杂对象时尤为关键。

![](../../../images/C&C++/Pasted%20image%2020250222171134.png)

#### 10.2. 委托

**委托（Delegation，Pointer to Implementation）** 将类的定义与类的实现分离开来。这种模式也被称为**编译防火墙（Compilation Firewall）**。委托模式的实现方式是**通过在类的定义中使用一个指向实现类的指针**（通常是一个不透明的指针，即 `pImpl` 指针），从而将类的具体实现细节隐藏在一个独立的实现类中。这样一来，当类的实现发生变化时，**只需重新编译实现类，而不需要重新编译依赖于该类的所有代码**。

![](../../../images/C&C++/Pasted%20image%2020250222171547.png)

#### 10.3. 继承

**继承（Inheritance）** 是面向对象编程中的一个核心概念，它用于描述**类与类之间的"is-a"关系**。这种关系表明，一个类（派生类）是另一个类（基类）的一种特殊形式。继承不仅允许派生类继承基类的属性和方法，还支持派生类对其进行**扩展或重写**，从而实现代码的重用和功能的扩展。

在标准模板库中，`_List_node`类的实现很好地展示了继承的应用。`_List_node`是STL中链表数据结构的一个基础节点类，它通常继承自一个基类，以便共享和复用基类中定义的数据成员和成员函数。通过继承，`_List_node`能够直接利用基类的特性，同时可以根据链表的具体需求添加或覆盖特定的功能。


![](../../../images/C&C++/Pasted%20image%2020250222172052.png)

继承关系下的对象的构造和析构遵循特定的顺序规则，通常总结为“**构造由内而外，析构由外而内**”，**和复合关系是一样的**。

![](../../../images/C&C++/Pasted%20image%2020250222172418.png)

### 11. 虚函数与多态

#### 11.1. 虚函数

在 C++ 编程中，类的成员函数可以分为以下三种类型：

1.  **非虚函数（Non-virtual Function）**：不希望被子类（派生类）重新定义（override）的普通成员函数
2.  **虚函数（Virtual Function）**：允许子类重新定义（override）的成员函数，**且基类中提供默认实现**
3.  **纯虚函数（Pure Virtual Function）**：必须在子类中重新定义的抽象成员函数，**基类中没有默认实现**

以下是三种不同虚函数的关键对比表及实现：

| 特性   | 非虚函数 | 虚函数    | 纯虚函数  |
|------|------|--------|-------|
| 可覆盖性 | 不可覆盖 | 可选择性覆盖 | 必须覆盖  |
| 默认实现 | 有    | 有      | 无     |
| 虚函数表 | 不使用  | 使用     | 使用    |
| 实例化  | 可实例化 | 可实例化   | 不可实例化 |
| 性能   | 最好   | 较好     | 最差    |

![](../../../images/C&C++/Pasted%20image%2020250222175536.png)

`error` 函数作为虚函数可以在派生类中重新定义其实现，**为不同子类提供特定的错误处理逻辑**；而 `draw` 函数作为纯虚函数（即声明后面带"=0"），要求所有继承该基类的子类**必须提供其具体实现**，它实际上定义了接口规范；至于 `objectID` 函数，明确禁止任何派生类对其进行重写，从而确保该函数在继承体系中的行为始终一致。

在MFC（Microsoft Foundation Classes）框架设计中，将父类 `CDocument` 的 `Serialize()` 函数声明为虚函数是一种常见的设计模式。这种设计允许框架使用者通过继承 `CDocument` 并重写 `Serialize()` 函数，在子类 `CMyDoc` 中实现具体的文件序列化逻辑。以下是该设计模式的流程示意图和相关代码实现。

|                         **流程示意图**                         |                            **代码**                            |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222180517.png) | ![](../../../images/C&C++/Pasted%20image%2020250222180530.png) |

#### 11.2. 构造函数调用关系

在 C++ 中，当一个子类继承了父类，并且还复合（组合）了其他类时，其构造函数的调用顺序是严格定义的

1.  **父类的构造函数**：如果子类继承了父类，首先**调用父类的构造函数**。
2.  **成员对象的构造函数**：如果子类中包含其他类的成员对象（复合关系），则按照它们在**类中声明的顺序**依次调用其构造函数。
3.  **子类自身的构造函数**：最后调用子类自己的构造函数。

![](../../../images/C&C++/Pasted%20image%2020250222181113.png)

对于子类继承父类，父类里复合了其他类的情况，构造及析构函数的调用顺序是一样的：

![](../../../images/C&C++/Pasted%20image%2020250222181125.png)

#### 11.3. 面向对象设计范例

##### 11.3.1. 使用委托+继承实现Observer模式

我们可以通过**委托（Delegation）** 和 **继承（Inheritance）** 相结合的方式，实现功能强大的**Observer模式**。这种设计模式特别适用于**多个窗口订阅同一份内容并保持实时更新的场景**，例如PPT演示文稿的窗口显示界面。以下是实现思路：

1.  **Subject类（被观察者）**：
    -   `Subject`类负责维护一个观察者列表（即 **vector<Observer*> m_views**），并提供**注册、移除和通知**观察者的接口。
    -   当`Subject`的状态发生变化时，它会通知所有注册的观察者，触发它们的**更新**操作。
2.  **Observer类（观察者）**：
    -   `Observer`类是一个抽象基类，定义了观察者的更新接口。
    -   具体的观察者（如窗口类）继承自`Observer`，并实现更新逻辑，以响应`Subject`的状态变化。
3.  **委托机制**：
    -   通过委托，`Subject`可以将通知观察者的任务委托给具体的观察者对象，从而实现松耦合的设计。
    -   委托机制允许`Subject`在运行时动态地添加或移除观察者，增强了系统的灵活性

|                          **窗口显示**                          |                            **代码**                            |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222182418.png) | ![](../../../images/C&C++/Pasted%20image%2020250222182451.png) |

##### 11.3.2. 使用委托+继承实现Composite模式

**Composite模式**是一种**结构型设计模式**，允许将对象组合成**树形结构**来表示“部分-整体”的层次结构。Composite模式使得客户端可以统一对待单个对象和组合对象。这种模式常常用于处理树形数据结构，例如**GUI界面的布局**、**文件系统的目录结构**等。

![](../../../images/C&C++/Pasted%20image%2020250222204328.png)

在这个示例中，`Component` 是树形结构中所有对象（包括初始节点和组合节点）的基类，`Primitive` 表示初始节点，`Composite` 表示组合节点。`Composite` 中包含了一个存储子节点的容器，可以**添加、移除和访问**子节点。客户端代码可以统一对待 `Primitive` 和 `Composite` 对象，调用它们的函数方法。

##### 11.3.3. 使用委托+继承实现Prototype模式

**Prototype模式**是一种**创建型设计模式**，核心思想是**通过复制现有对象来创建新对象**，而不是通过构造函数或工厂方法。这种模式特别适用于以下场景：

1.  当创建对象的成本较高（例如，对象初始化需要大量资源或时间）。
2.  当需要创建的对象与现有对象相似，仅有少量差异。
3.  当希望避免使用子类来扩展对象的行为。

![](../../../images/C&C++/Pasted%20image%2020250222205830.png)

假设我们正在开发一个游戏，游戏中有多种类型的怪物（如僵尸、骷髅等）。每个怪物都有一些共享的属性（如生命值、攻击力），但也有独特的特性。我们就可以使用Prototype模式来创建新的怪物实例，复用父类声明的函数。

```Cpp
#include <iostream>
#include <memory>
#include <string>

// 1. 定义原型接口
class Monster {
public:
    virtual ~Monster() = default;
    virtual std::unique_ptr<Monster> clone() const = 0;
    virtual void attack() const = 0;
    virtual void setHealth(int health) = 0;
    virtual int getHealth() const = 0;
};

// 2. 实现具体原型类
class Zombie : public Monster {
private:
    int health;

public:
    Zombie(int health = 100) : health(health) {}

    std::unique_ptr<Monster> clone() const override {
        return std::make_unique<Zombie>(*this); // 使用拷贝构造函数实现克隆
    }

    void attack() const override {
        std::cout << "Zombie attacks with bite! (Health: " << health << ")" << std::endl;
    }

    void setHealth(int health) override {
        this->health = health;
    }

    int getHealth() const override {
        return health;
    }
};

class Skeleton : public Monster {
private:
    int health;

public:
    Skeleton(int health = 80) : health(health) {}

    std::unique_ptr<Monster> clone() const override {
        return std::make_unique<Skeleton>(*this); // 使用拷贝构造函数实现克隆
    }

    void attack() const override {
        std::cout << "Skeleton attacks with bow! (Health: " << health << ")" << std::endl;
    }

    void setHealth(int health) override {
        this->health = health;
    }

    int getHealth() const override {
        return health;
    }
};

// 3. 客户端代码
int main() {
    // 创建原型对象
    auto zombiePrototype = std::make_unique<Zombie>(100);
    auto skeletonPrototype = std::make_unique<Skeleton>(80);

    // 通过克隆创建新对象
    auto zombie1 = zombiePrototype->clone();
    auto skeleton1 = skeletonPrototype->clone();

    // 修改克隆对象的属性
    zombie1->setHealth(90);
    skeleton1->setHealth(70);

    // 测试克隆对象
    zombie1->attack();    // 输出: Zombie attacks with bite! (Health: 90)
    skeleton1->attack();  // 输出: Skeleton attacks with bow! (Health: 70)

    return 0;
}
```

Prototype模式通常通过**拷贝构造函数**或**拷贝赋值运算符**来实现。使用智能指针（如`std::unique_ptr`）可以更方便地管理动态分配的对象。

---

## 参考引用

### 书籍出处

- [01-C++面向对象高级编程（上）](../../../asset/C&C++/01-C++面向对象高级编程（上）.pdf)
- [02-C++面向对象高级编程（下）](../../../asset/C&C++/02-C++面向对象高级编程（下）.pdf)

### 网页链接

- [C++ 编程习惯与编程要点](https://mp.weixin.qq.com/s/UISvMLlVsAcy4xvp8qONfA)
- [侯捷C++课程笔记01: 面向对象高级编程（上）_侯捷c++课程哪里有讲指针-CSDN博客](https://blog.csdn.net/ncepu_Chen/article/details/113843775)
## 01 - 面向对象的高级编程

---

### 1. 头文件与类的声明

针对头文件`complex.h`的结构，主要可以分为以下四个部分：

```cpp
#ifndef __MYCOMPLEX__
#define __MYCOMPLEX__

#include <cmath>

class ostream;
class complex;

complex&
__doapl (complex* ths, const complex& r);

class complex {
 ...
}

complex::function ...

# endif
```

1. **防卫式声明**：通过`#ifndef`、`#define`、`#endif`防止头文件被重复包含

```cpp
#ifndef __MYCOMPLEX__
#define __MYCOMPLEX__

...

# endif
```

- 优先包含标准库头文件
- 按依赖顺序声明自定义类型
- 避免不必要的包含，减少编译依赖
- 推荐使用全大写命名格式，例如：PROJECTNAME_MODULENAME_FILENAME_H
- 现代C++可使用`#pragma once`替代（编译器扩展，非标准但广泛支持），编译器在识别到#pragma once后直接跳过后续内容，比传统宏防卫（需扫描到#endif）更快。

```Cpp
#pragma once
#ifndef MY_HEADER_H
#define MY_HEADER_H
// 头文件内容...
#endif
```

**与#ifndef宏的对比**

| **特性**             | **pragma once**          | **ifndef宏防卫**             |
|:---------------- |:-------------------- |:------------------------ |
| 标准支持         | 非标准，但主流支持   | 符合C/C++标准            |
| 使用复杂度       | 一行代码             | 需定义唯一宏名，三行代码 |
| 编译速度         | 更快（提前终止解析） | 较慢（需扫描到#endif）   |
| 跨平台稳定性     | 依赖编译器支持       | 所有编译器通用           |
| 处理相同内容文件 | 无法解决             | 宏名唯一即可解决         |

**兼容性**

| 编译器类型                | 行为                                    |
|----------------------|---------------------------------------|
| 支持#pragma once的编译器   | 直接跳过后续重复包含，无需处理#ifndef逻辑，提升编译速度       |
| 不支持#pragma once的旧编译器 | 忽略#pragma once，继续执行#ifndef宏防卫逻辑，保证兼容性 |


2. **前置声明**: 提前声明头文件中用到的类和函数，为后续代码准备好依赖关系

```cpp
#include <cmath>

class ostream;
class complex;

complex&
__doapl (complex* ths, const complex& r);
```

3. **类声明**: 在类声明中定义类的函数和变量，并可以实现一些简单的函数

```cpp
class complex {
 ...
}
```

4. **类定义**: 实现前面声明的函数，在这里完成类成员函数的具体实现

```Cpp
complex::function ...
```

### 2. 构造函数

#### 2.1. 访问级别

在C++中，共有三种访问级别，这段程序展示了其中的两种:

| **访问级别** |            **意义**            |
| ------------ |:------------------------------:|
| private      |      只能被**本类的函数**访问      |
| protected    | 能被**本类的函数**和**子类的函数**访问 |
| public       |       可以被所有函数访问       |

将数据成员放在private声明下，提供接口函数访问数据，从而保证数据的安全性:

```Cpp
class complex {
    public:
        complex(double r = 0, double i = 0):
            re(r), im(i) {}
        complex &operator+=(const complex &);
        double real() const { return re; }
        double imag() const { return im; }

    private:
        double re, im;
        friend complex &__doapl(complex*, const complex &);
};
```

![](/images/C&C++/Pasted%20image%2020250220121002.png)

#### 2.2. 内联函数

在类声明内定义的函数会自动成为`inline`函数；在类声明外定义的函数需要显式加上`inline`关键字才能成为`inline`函数

|      **类声明内定义的函数,自动成为`inline`函数**      | **类声明外定义的函数需在定义时加上`inline`关键字才能成为`inline`函数** |
|:-----------------------------------------------------:|:-----------------------------------------------------------------:|
| ![](/images/C&C++/Pasted%20image%2020250220120142.png) |       ![](/images/C&C++/Pasted%20image%2020250220120332.png)       |

`inline`只是编程者给编译器的一个建议，在编译时未必会真正被编译为`inline`函数。因此如果函数足够简单，我们就把它声明为`inline`就行

#### 2.3. 构造函数

构造函数可以使用默认实参和成员**初始化列表**。而在构造函数体内的赋值和在初始化列表中的初始化是不同的

![](/images/C&C++/Pasted%20image%2020250220121127.png)

**在初始值列表中，才是初始化**。在构造函数体内的，叫做赋值。上面两种构造函数的效果是一样的，但是使用列表初始化的效率更高，应尽量使用列表初始化。

```Cpp
// 推荐写法（初始化列表）
complex(double r = 0, double i = 0) : re(r), im(i) {}

// 不推荐写法（函数体内赋值）
complex(double r = 0, double i = 0) { re = r; im = i; }
```

默认实参使得类的使用者更灵活地创建对象：

```Cpp
complex c1;          // 等效于complex(0, 0)
complex c2(5);       // 等效于complex(5, 0)
complex c3(2, 1);    // 标准构造
complex* p = new complex(4);  // 动态分配
```

#### 2.4. 函数重载

构造函数的重载应避免歧义。使用默认实参时应注意，避免编译器出现歧义导致的编译失败，以免导致使用者在创建对象时遇到错误：

![](/images/C&C++/Pasted%20image%2020250220121634.png)

```Cpp
complex c1(2, 1);	// 这一行编译通过
complex c2;			// 这一行编译失败: error: call of overloaded 'complex()' is ambiguous
```

### 3. 参数传递与返回值

#### 3.1. 常量成员函数

**对于不改变类属性（数据成员）的成员函数，务必加上 `const` 声明。**

```Cpp
double real () const {return re;}  
double imag() const {return im;}
```

通过在函数后加上 `const`，我们明确表示这个函数不会修改对象的状态。这一声明不仅能够帮助编译器进行更好的优化，也能让阅读代码的人员更清楚地理解函数的意图。此外，只有 `const` 对象才能调用这些带有 `const` 修饰符的成员函数——即 `const` 对象无法调用非 `const` 的成员函数。

如果这类函数不添加 `const` 修饰，常量对象将无法调用这些函数:

![](/images/C&C++/Pasted%20image%2020250220203900.png)

#### 3.2. 参数的值传递和引用传递

函数的参数尽量使用引用传递，这样可以避免参数的复制。同时，使用 `const` 可以确保这些参数在函数内部不会被意外修改。对于内置类型，值传递与引用传递的效率差别并不显著，甚至在某些情况下，值传递可能更高效。例如，传递 `char` 类型时，值传递仅需传递一个字节；**而使用引用传递时实际上需要传递一个指针，这在 32 位机上需要四个字节的开销**。然而，为了保持代码的一致性，建议统一使用引用传递。

![](/images/C&C++/Pasted%20image%2020250220204826.png)

#### 3.3. 返回值的值传递和引用传递

![](/images/C&C++/Pasted%20image%2020250220205139.png)

为了提高效率，如果**函数的返回值是一个已经存在的对象**，应该以引用的形式返回。**对于临时变量，返回值只能通过值传递**。

以 `operator+=` 为例，它的返回值是引用，因为在执行 `a += b` 时，`a` **已经在内存中存在**。相比之下，`operator+` 不能以引用的形式返回，因为 `a + b` 的结果是在调用 `operator+` 时**才会产生的临时值**。返回这个临时值的引用将导致不确定的行为，因为该临时对象在函数返回后会被销毁。

```cpp
inline complex & complex :: operator += (const complex & r)  
{  
        this -> re+= r->re;  
        this -> im+= r->im;  
        return * this;  
}  
inline complex operator + (const complex & x , const complex & y)  
{  
        return complex ( real (x)+ real (y),                        //新创建的对象，不能返回引用  
                                 imag(x)+ imag(y));  
}
```

在 `operator+=` 中返回引用是必需的，这样可以支持链式操作。例如：

```Cpp
a += b += c; 
```

在这个表达式中，首先计算 `b += c`，然后将其结果直接用于更新 `a`。由于 `operator+=` 返回的是对 `a` 的引用，这样的设计便于连续的操作，提升了代码的简洁性和可读性。如果 `operator+=` 返回的是值而不是引用，就无法进行链式调用。

#### 3.4. 友元函数

**友元函数不受访问控制的限制，可以自由访问类中所有成员，包括私有成员和保护成员**。即使函数不属于类的成员，其依然能够访问该类的私有数据。尽管友元函数能够访问类的私有成员，但这通常会打破封装性，因此在使用友元函数时应谨慎。

![](/images/C&C++/Pasted%20image%2020250220205803.png)

**同一类的各个对象互为友元**，则类定义里可以**自由访问彼此的私有成员变 量和保护成**员

![](/images/C&C++/Pasted%20image%2020250220210148.png)

```Cpp
complex c1, c2;
c2.func(c1);		// 因为c1和c2互为友元,因此c2可以在func()函数内调用c1的私有变量
```

### 4. 操作符重载

在C++中，操作符重载可以通过两种方式实现：一种是在**类内定义公共成员函数**以重载操作符，这样操作符将作用于左操作数；另一种是在**类外定义全局函数**进行重载。

以下是关于如何重载操作符“+”的示例：

```Cpp
complex c1;
c1 + 2;  // 需要重载操作符“+”
```

我们可以通过两种方式来实现操作符的重载：

1.  在类内声明公共成员函数，形式为 `complex::operator+= (int)`。
2.  在类外声明全局函数，形式为 `complex operator+ (const complex&, double)`。

这两种方法都可以实现操作符的重载。

#### 4.1. 类内声明 public 函数重载 +=

在重载 `+=` 运算符的 `complex::operator+= (const complex& r)` 函数中，输入参数和输出参数均采用**传引用**的形式。为了确保输入参数在函数内部不被修改，我们使用 `const` 关键字进行修饰。

输出参数的类型为 `complex&`，这是为了支持多个 `+=` 操作的链式调用。如果将返回类型设定为 `void`，虽然仍然可以执行形式为 `c2 += c1` 的运算，但将无法实现如 `c3 += c2 += c1` 的链式运算，因此这种设计可以提升操作的灵活性与表达能力。

![](/images/C&C++/Pasted%20image%2020250220212245.png)

在函数体内，我们调用了友元函数 `__doapl(complex *, const complex &)` 来实现具体的功能。该函数的第一个参数接收成员函数中隐含的 `this` 指针，**该指针所指向的内容可能会在函数内部被修改（即+=的左边）**。第二个参数则接收重载函数的参数，并且使用 `const` 关键字进行修饰，以确保在函数内部该参数不会被修改。

这个例子清楚地表明了使用引用传递参数和返回值所带来的优势。**传送者无需关心接收者是以引用形式接收参数，还是以值传递的方式进行处理**。传送者只需像使用值传递那样编写代码，不必做任何修改。**任何成员函数都有一个隐藏的 this pointer**。

![](/images/C&C++/Pasted%20image%2020250220212408.png)

#### 4.2. 在类外声明或函数重载+

在重载运算符时，我们需要考虑是否支持多种不同的用法。在我们的复数类中，运算符 `+` 可能会有多种应用方式，例如：

```Cpp
complex c1(2, 1);
complex c2;

c2 = c1 + c2;    // 用法1: complex + complex
c2 = c1 + 5;     // 用法2: complex + double
c2 = 7 + c1;     // 用法3: double + complex
```

由于运算符重载的成员函数是作用于左操作数的，因此，如果我们将类内运算符声明为 `public` 成员函数的方式，就无法支持第三种用法。所以我们需要在**类外声明相应的重载函数**来适应这些不同的加法场景。为此，`+` 运算符需要提供以下三种重载形式：

```Cpp
inline complex operator+(const complex &x, const complex &y) {
    return complex(real(x) + real(y), 
				   imag(x) + imag(y));
}

inline complex operator+(const complex &x, double y) {
    return complex(real(x) + y, imag(x));
} 

inline complex operator+(double x, const complex &y) {
    return complex(x + real(y), imag(y));
}

```

这三个函数返回的是**局部对象（local object）**，在函数执行结束后，这些对象会被销毁。因此，使用**传引用**来返回这些值是不合适的，即**函数内的加法结果是个临时变量，在内存中并不存在，函数执行完毕后就销毁**。Typename () 小括号就是创建临时对象，右图黄色两个临时变量在赋值完毕后就销毁，所以无法调用。如果 double y 是一个**常量或临时值**，传引用可能会导致编译错误或未定义行为，所以**传值**。

![](/images/C&C++/Pasted%20image%2020250220213900.png)

函数重载是根据传入的参数类型和参数个数来区分不同的函数实现的，如下图所示：

![](/images/C&C++/Pasted%20image%2020250220214604.png)

因为**取正函数**并没有产生新的临时变量，故也可以使用传引用 `inline complex&` 的写法。

其他操作符重载：

![](/images/C&C++/Pasted%20image%2020250220220005.png)

![](/images/C&C++/Pasted%20image%2020250220215359.png)

#### 4.3. 在类外声明函数重载<<

与重载+操作符类似，<<操作符通常使用方式是 `cout << c1` 而不是 `c1 << cout`，因此**不能使用成员函数重载<<操作符**。考虑到类似 cout << c1 << c2 << c3 的级联用法，**重载函数的返回值应为 ostream& 而非 void**，即**传引用**。

![](/images/C&C++/Pasted%20image%2020250220215335.png)

**第一个参数 ostream& os 就是 cout，cout 是一个 ostream 对象**，不能加 const（即 operator << (const ostream& os, const complex& x)），因为 cout 的状态在每次执行后会发生改变。返回值是 ostream&，以便支持连续输出。**优先使用传引用**，且不加 const，也是因为 cout 的值会改变。

### 5. 编写类的注意事项

编写类时应注意以下五个要点，可以看出你写的代码是否大气：

1.  在构造函数中使用**初始化列表**为成员变量赋值：
2.  使用 **const** 修饰常量成员函数。
3.  **尽量使用引用传递参数**，在不修改参数的情况下应**添加 const 修饰**。
4.  若返回值**不是局部变量**，应尽量使用引用传递返回。
5.  将**数据放入 private 成员**中，将大部分**函数放入 public 成员**中。

### 6. Big Three：拷贝构造、拷贝赋值、析构

`String`类定义在头文件`string.h`中,其结构与`complex.h`类似

![](/images/C&C++/Pasted%20image%2020250221151031.png)

#### 6.1. 构造函数和析构函数

对于不带有指针的类，编译器会为我们自动生成默认的构造函数、拷贝构造函数和析构函数。但是**对于带有指针的类，特别是动态分配内存的情况，是有必要手动定义这三个特殊函数的**：

1.  **构造函数**：需要确保指针成员正确初始化，以避免悬空指针或内存泄漏的问题。
2.  **拷贝构造函数**：需要深拷贝指针指向的内容，以防止浅拷贝导致的多个对象指向同一内存地址，造成释放重复内存或释放无效内存的问题。
3.  **析构函数**：需要释放动态分配的内存，以防止内存泄漏。

```Cpp
int main() {
    String s1("hello");
    String s2("world");

    String s3(s2);        // 调用拷贝构造函数
    cout << s3 << endl;

    s3 = s1;              // 调用拷贝赋值函数
    String s4 = s1;       // 调用拷贝构造函数
    cout << s3 << endl;
    cout << s2 << endl;
    cout << s1 << endl;
}
```

类声明如下，使用指针成员变量`m_data`来管理`String`类中的字符串数据。

![](/images/C&C++/Pasted%20image%2020250221152145.png)

```cpp
class String {
    public:
        String(const char* cstr = nullptr);        // 默认构造函数，默认实参为 0
        String(const String &str);                 // 拷贝构造函数
        String &operator=(const String &str);      // 拷贝赋值函数
        ~String();                                 // 析构函数
        
        // 获取字符串，const 修饰成员函数，确保不会修改数据成员
        char* get_c_str() const {
            return m_data;
        }

    private:
        char* m_data;
};
```

使用指针 `m_data` 指向 `new` 分配的空间。在进行拷贝构造后，新创建的对象就包含了指向的内容。注意使用`delete[]`操作符释放动态分配的数组内存，而不是直接使用`delete`操作符。虽然直接使用`delete`操作符也可以通过编译，但可能会导致**内存泄漏**。函数离开作用域会调用三次析构函数

![](/images/C&C++/Pasted%20image%2020250221154041.png)

#### 6.2. 拷贝构造函数和拷贝赋值函数

**默认的拷贝构造函数**和**赋值构造函数**执行的是**浅拷贝**（Shallow Copy），即对对象的内存进行**逐位的复制**。在C++中，仅仅复制了对象的成员变量，包括指针本身，而**不会复制指针所指向的实际内容**。现在有两个`String`对象：

```cpp
String a("Hello");  
String b("World");
```

a、b在内存上如图所示：

![](/images/C&C++/Pasted%20image%2020250221160600.png)

如果此时执行：

```Cpp
b = a;
```

浅拷贝体现为：

![](/images/C&C++/Pasted%20image%2020250221160706.png)

存储 `World\0` 的内存块没有指针指向它，因此变成了无法访问的内存块，从而造成了**内存泄漏**。此外，如果此时对象a被删除，并且使用我们之前提到的析构函数释放了存储 `Hello\0` 的内存块，那么对象b中的`m_data`指针现在会变成悬空指针（dangling pointer）。悬空指针是指指向之前分配的内存，但此内存已经被释放的情况，使用悬空指针会导致未定义行为。

拷贝构造函数的实现较为简单，只需使用**友元对象的数据指针**进行**深拷贝**：

![](/images/C&C++/Pasted%20image%2020250221161131.png)

拷贝赋值函数时，需要检查是否为自我赋值。这不仅有助于提高效率，还可以避免出现潜在的 bug：

![](/images/C&C++/Pasted%20image%2020250221161722.png)

1. 释放之前分配的内存
2. 分配一个与目标字符串相同大小的内存块
3. 将字符串复制到新分配的内存中

对于`a = b`，1 2 3 过程如下：

|                         步骤1                         |                         步骤2                         |                         步骤3                         |
|:-----------------------------------------------------:|:-----------------------------------------------------:|:-----------------------------------------------------:|
| ![](/images/C&C++/Pasted%20image%2020250221162113.png) | ![](/images/C&C++/Pasted%20image%2020250221162126.png) | ![](/images/C&C++/Pasted%20image%2020250221162151.png) |

**注意**：**operator = 一定要检查是否存在自我赋值情况**。如果出现自我赋值，即左右操作数指向同一内存块，**那么在删除该内存块后对右操作数的内存访问将导致未定义行为**，即上图的 `s2 = s1`。

![](/images/C&C++/Pasted%20image%2020250221162242.png)

### 7. 堆栈与内存管理

#### 7.1. 堆栈及对象的生命周期

- **栈（stack）**：存在于某作用域 (scope) 的一块內存空间(memory space)。例如调用函数，函数本身即会形成一个栈用来放置它所接收的参数，以及返回地址。**在函数体 (function body) 內声明的任何变量，其所使用的內存块都取自上述栈**。
- **堆（Heap）**：指由操作系統提供的一块全局內存空间，程序可动态分配 (dynamic allocated) 从其中获得若干区块 (blocks)。

![](../../../images/C&C++/Pasted%20image%2020250221221104.png)

1. **stack object的生命周期**：

在C++中，栈对象（stack object）的生命周期与其所在的作用域紧密相关。以下代码展示了一个典型的使用示例：

```Cpp
class Complex { ... };
// ...
    
{
Complex c1(1,2);
}
```

在这个示例中，`c1` 是一个**栈对象**。它的生命周期从创建的那一刻开始，到其所在的作用域（由大括号 `{}` 界定）结束时终止。在这个作用域结束时，`c1` 会自动被清理，因此这种对象也被称为**自动对象（auto object）**。这种自动清理的机制有助于简化内存管理，避免内存泄漏。

2. **static object的生命周期**

```Cpp
class Complex { ... };
// ...

{
    static Complex c2(1, 2);
}
```

在这个程序中，`c2` 是一个**静态对象（static object）**。与栈对象不同，`c2` 的生命周期并不局限于其作用域（即大括号内）。即使作用域结束，`c2` 仍然存在，**直到整个程序结束时才会被销毁**。这种特性使得静态对象能够在多次函数调用之间保持其状态，是一种**全局性的存储机制**。

3. **global object的生命周期**

```cpp
class Complex { ... };
// ...

Complex c3(1, 2);

int main()
{
    ...
}
```

在这个程序中，`c3` 是一个**全局对象（global object）**，其生命周期延伸至整个程序的运行周期。**可以将全局对象视为一种静态对象（static object）**，其作用域涵盖整个程序。

4. **heap object的生命周期**

```cpp
class Complex { ... };
// ...

{
    Complex* p = new Complex;
    // ...
    delete p;
}
```

![](../../../images/C&C++/Pasted%20image%2020250221221948.png)

在这个程序中，`p` 指向的对象是堆对象（heap object）。堆对象的生命周期在调用 `delete` 释放它的内存时结束。如果在作用域结束时忘记释放 `p` 指向的堆对象，将会导致**内存泄漏**，即堆对象仍然存在，但无法再通过指针 `p` 访问它，因为指针 `p` 的生命周期已经结束，作用域外无法再操作 `p` 指向的堆对象。

#### 7.2. new 和 delete 过程中的内存分配

|             `new`操作**先分配内存，再调用构造函数**             |           `delete`操作**先调用析构函数，再释放内存**            |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222111332.png) | ![](../../../images/C&C++/Pasted%20image%2020250222111345.png) |

对于带有指针的`String`类,`new`操作和`delete`操作的示意图如下:

|                            **new**                             |                           **delete**                           |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222111456.png) | ![](../../../images/C&C++/Pasted%20image%2020250222111507.png) |

##### 7.2.1. 内存分配

C++分配内存和释放内存，实际上是**使用了 C 语言的 malloc 和 free 函数**。VC中对象在 `Debug` 模式和 `Release` 模式下的内存分布如下图所示。变量在内存中所占字节数必须被补齐为 16 的倍数。红色代表 Cookie 保存内存块的大小，其**最低位的 1 和 0 分别表示内存是否被回收**。`Debug` 模式下 Complex 对象绿色部分因为**算出的大小为52不是16的倍数**，因此需要额外的填充(padding)来补齐到64字节，以确保内存对齐和性能。64字节对应十六进制为`0x40`，而在cookie中表示为`41`，表示内存块已经**被分配**。

|                        **Complex对象**                         |                         **String对象**                         |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222113616.png) | ![](../../../images/C&C++/Pasted%20image%2020250222113634.png) |

##### 7.2.1. 数组分配

|                        **Complex对象**                         |                         **String对象**                         |
|:--------------------------------------------------------------:|:--------------------------------------------------------------:|
| ![](../../../images/C&C++/Pasted%20image%2020250222114003.png) | ![](../../../images/C&C++/Pasted%20image%2020250222114136.png) |

在 C++ 中，**良好的编程习惯是严格匹配内存分配与释放的方式**，即使用 `new[]` 分配的内存必须用 `delete[]` 释放，而使用 `new` 分配的内存必须用 `delete` 释放，否则可能会导致未定义行为或内存泄漏。如果错误地使用 `delete` 释放通过 `new[]` 分配的内存，或者使用 `delete[]` 释放通过 `new` 分配的内存，程序对于数组对象，**部分元素的析构函数可能未被调用**。

![](../../../images/C&C++/Pasted%20image%2020250222114343.png)


















---

## 参考引用

### 书籍出处

- [01-C++面向对象高级编程（上）](../../../asset/C&C++/01-C++面向对象高级编程（上）.pdf)
- [02-C++面向对象高级编程（下）](../../../asset/C&C++/02-C++面向对象高级编程（下）.pdf)

### 网页链接

- [C++ 编程习惯与编程要点](https://mp.weixin.qq.com/s/UISvMLlVsAcy4xvp8qONfA)
- [侯捷C++课程笔记01: 面向对象高级编程（上）_侯捷c++课程哪里有讲指针-CSDN博客](https://blog.csdn.net/ncepu_Chen/article/details/113843775)
- [侯捷C++课程笔记02: 面向对象高级编程（下）-CSDN博客](https://blog.csdn.net/ncepu_Chen/article/details/114686488)
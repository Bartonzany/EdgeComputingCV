## 2 - 信息的表示和处理

---

### 1. 信息存储

- **字节（Byte）**：最小的可寻址的内存单位，一般为 8 位
- **虚拟内存（virtual memory）**：程序将内存视为一个非常大的字节数组
- **地址（address）**：内存的每个字节都由 一 个唯一的数字来标识
- **虚拟地址空间 (virtual address space)** ：所有可能地址的 集 合

#### 1.1. 十六进制表示法

一个字节由 8 位组成，在二进制表示法中，它的值域是 $00000000_2 \sim 11111111_2$。如果看成十进制整数，它的值域就是 $0_{10} \sim 255_{10}$。十六进制使用数字 '0'~'9' 以及字符 'A'~'F' 来表示 16  个可能的值。下图展示了 16 个十六进制数字对应的十进制值和二进制值。

![](/images/CSAPP/Pasted%20image%2020250111195718.png)

C 语言中，以 0x 或 0x 开头的数字常量是十六进制值。字符 'A'~'F' 既可以是大写 ，也可以是小写。例如，可以将数字 $FA1D37B_{16}$ 写作 0xFA1D37B，或者 0xfald37b, 甚至是大小写混合，比如，0xFa1D37b。进制的转换可以参照上表相对关系来完成。

**二进制转十六进制**可用以下转换关系实现：

$$
\begin{align*} 
x&=2^n \\
n&=i+4j, 0 \leq i \leq 3 \\
\end{align*}
$$
当 n 表示成 $i+4j$ 的形式，可以把 x 写成开头的十六进制数字为 1(i=0)、2(i=1)、4(i=2) 或者 8(i=3)，后面跟随着 j 个十六进制的 0。比如 $x=2048=2^{11}，n=11=3+ 4 \cdot 2$，从而得到十六进制表示 0x800。

**十进制转十六进制**需要使用乘法或者除法来处理。将一个十进制数字 x 转换为十六进制，可以反复用 16 除 x，得到一个商 q 和一个余数 r，也就是 $x=q \cdot 16+r$，用十六进制数字表示的 r 作为最低位数字。如下图十进制 314156 转十六进制，可以得到十六进制表示为 0x4CB2C

![](/images/CSAPP/Pasted%20image%2020250111201523.png)

**十六进制转换十进制数字**可以用相应的 16 的幂乘以每个十六进制数字。比如给定数字 0x7AF，计算对应的十进制值为 $7 \cdot 16^2+10^{16}+15=7 \cdot 256+10 \cdot 16+15=1792+160+15=1967$

#### 1.2. 字数据大小

每台计算机都有一个**字长 (word size)**，决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为 w 位的机器而言，虚拟地址的范围为 $0 \sim 2^w-1$。32 位字长限制虚拟地址空间为 4GB，64 位则为 16EB。**大多数 64 位机器也可以运行为 32 位机器编译的程序**，这在运行一些window系统软件非常常见。下图为不同字长系统对于 C 中的数据类型的大小。

![](/images/CSAPP/Pasted%20image%2020250111202742.png)

为了避免由于不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 int32 t 和 int64 七，它们分别为 4 个字节和 8 个字节。**程序员应该力图使他们的程序在不同的机器和编译器上可移植**。

#### 1.3. 寻址和字节顺序

在几乎所有的机器上，多字节对象都被存储为**连续的字节序列**，对象的地址为所使用**字节中最小的地址**。例如，假设一个类型为 int 的变量 x 的地址为 0x100，那么 x 的 4 个字节将被存储在内存的 0x100 、0x101、0x102 和 0x103 位置。

数据的寻址有大端法和小端法两种方式：

- **小端法 (little endian)** ：最低有效字节在最前面的方式
- **大端法 (big endian)** ：最高有效字节在最前面的 方式

假设变 量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567。地址范围 0x100 ~ 0x103 的字节顺序依赖于机器的类型：

![](/images/CSAPP/Pasted%20image%2020250111203534.png)

大多数 Intel PC机都只用小端模式，IBM 和 Oracle的大多数机器则是按大端模式。许多比较新的微处理器是双端法 (bi-endian)，也就是说可以把它们配置成作为大端或者小端的机器运行。最常见的两种操作系统 Android 和 IOS 只能运行小端模式。

在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准。

以下代码是在不同机器上的显示结果：

![](/images/CSAPP/Pasted%20image%2020250111204837.png)

![](/images/CSAPP/Pasted%20image%2020250111204856.png)

![](/images/CSAPP/Pasted%20image%2020250111204920.png)

#### 1.4. 表示字符串

十进制数字 x 的 ASCII 码正好是 0x3x，字母 'a'~'z' 的 ASCII 码为 0x61~0x7A

#### 1.5 表示代码

```C
int sum(int x, int y) {
	return x + y;
}
```

当在示例机器上编译时，生成如下字节表示的机器代码：

```text
Linux32    55 89 e5 8b 45 0c 03 45 08 c9 c3
Windows    55 89 e5 8b 45 0c 03 45 08 5d c3
Sun        81 c3 e0 08 90 02 00 09
Linux64    55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3
```

发现**指令编码是不同的**。不同的机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

#### 1.6 布尔代数简介

![](images/CSAPP/Pasted%20image%2020250111210326.png)

可以将上述 4 个布尔运算扩展到位向量的运算。举个例子，假设 w=4，参数 a= [0110] , b= [1100] 。那么 4 种运算 a&b、a l b、a ^ b 和 ~b 分别得到以下结果：

![](/images/CSAPP/Pasted%20image%2020250111210459.png)

位向量一个很有用的应用就是表示有限集合，可以用位向量 $[a_{w−1}, ..., a1, a0]$ 编码任何子集 $A \subseteq \{0,1,...,w-1\}$。位向量并集的例子：a=[01101001] 表示{0，3，5，6}，b=[01010101] 表示{0，2，4，6}。最终二者并集 a&b =[01000001]={0，6}。注意是从右往左数，1 为相对应的位置。位向量多用于掩码的表示。

#### 1.7. C 语言中的移位运算

即向左或者向右移动位模式，下表给出了对一个 8 位参数 x 的两个不同的值做不同的移
位操作得到的结果：

![](/images/CSAPP/Pasted%20image%2020250111211849.png)

可以看到，逻辑运算是填充 0，算术运算是填充 1。C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。

### 2. 整数表示

#### 2.1. 整型数据类型

下图是 32 位和 64 位上 C 的整数类型取值范围。唯一一个与机器相关的取值范围是 long
，大多数 64 位机器使用 8 个字节的表示，比 32 位机器上使用的 4 个字节的表示的取值
范围大很多。

![](/images/CSAPP/Pasted%20image%2020250114213911.png)

![](/images/CSAPP/Pasted%20image%2020250114213932.png)

#### 2.2. 无符号数的编码

![](/images/CSAPP/Pasted%20image%2020250114214348.png)

![](/images/CSAPP/Pasted%20image%2020250114214410.png)

![](/images/CSAPP/Pasted%20image%2020250114214537.png)

#### 2.3. 补码编码

![](/images/CSAPP/Pasted%20image%2020250114214625.png)

![](/images/CSAPP/Pasted%20image%2020250114214653.png)

![](/images/CSAPP/Pasted%20image%2020250114214714.png)

在这个图中，用向左指的条表示符号位具有负权重。一个位向量相关联的数值是由向左指和向右指的长度相加决定。

![](/images/CSAPP/Pasted%20image%2020250114215148.png)

上图是用补码表示的整数取值范围，C 语言也一般用补码形式来表示有符号整数。C 库中的文件＜limits.h> 定义了一组常量，来限定编译器运行的机器不同整型数据类型的取值范围。比如，它定义了常量 **INT_MAX** 、**INT_MIN** 和 **UINT_MAX**, 它们描述了有符号和无符号整数的范围。

为了更好地理解补码表示，考虑 下面的代码：

```C
short x = 12345;
short mx = -x;

show_bytes((byte_pointer) &x, sizeof(short));
show_bytes((byte_pointer) &mx, sizeof(short));
```

当在大端法机器上 运 行时，这段代码的输出为 30 39 和 cf c7，指明 x 的十六进制表示为 0x3039，而 mx 的十六进制表示为 0xCFC7。将它们展开为二进制，得到 x 的为 [0011000000111001]，而 mx 的位模式为 [1100111111000111] 。如图所示：

![](/images/CSAPP/Pasted%20image%2020250114221050.png)

**反码**：最高有效位的权是 $-(2^{w-1}-1)$，其他和补码一致

![](/images/CSAPP/Pasted%20image%2020250115195726.png)

**原码**：最高有效位是符号位，用来确定剩下的位应该取负权还是正权：

![](/images/CSAPP/Pasted%20image%2020250115195759.png)

从公式同样可以看出，当最高位是0时，反码和原码解释得到的值是一样的，

- 0b0000 0000 ---> 原码表示0，反码也是表示0.

但当最高位是1时，

- 0b1000 0000 ---> 原码表示0，反码表示-127

可以看出，使用原码表示 0 的值不一致。

#### 2.4. 有符号数和无符号数之间的转换

**补码转换为无符号数**：

![](/images/CSAPP/Pasted%20image%2020250114221526.png)

比如，$T2U_{16} (-12345)= -12345+2^{16}=53191$。另外一个例子是 $w=4$ 时，补码最高有效位是符号位，用带向左箭头的条表示；无符号数最高有效位是正权重，用带向右的箭头的条表示。从补码变为无符号数，最高有效位权重从 -8 变为 +8。因此，补码表示的负数如果看成无符号数，值会增加 $2^4=16$，因而 -5 变成了 +11，而 -1 变成 +15。 

![](/images/CSAPP/Pasted%20image%2020250114222358.png)

下图进一步图示了从补码到无符号数的转换：

![](/images/CSAPP/Pasted%20image%2020250114222446.png)

**无符号数转换为补码**：

![](/images/CSAPP/Pasted%20image%2020250114222506.png)

![](/images/CSAPP/Pasted%20image%2020250114222704.png)

#### 2.5. C 语言中的有符号数与无符号数

因为大部分机器使用补码表示无符号数和有符号数，所以套用补码转换为无符号数（**有符号数转换为无符号数**）和无符号数转换为补码（**无符号数转换为有符号数**）。例如以下例子：

```C
int x = -1;
unsigned u = 2147483648; /* 2 to the 31st */

printf("x = %u = %d\n", x, x);
printf("u = %u = %d\n", u, u);
```

输出如下：

```text
x = 4294967295 = -1
u = 2147483648 = -2147483648
```

printf 首先将这个字当作一个无符号数输出，然后把它当作一个有符号数输出。使用了  $T2U_{32}(−1) = UMax_{32} = 2^{32} − 1$ 和 $U2T_{32}(2^{31}) = 2^{31} − 2^{32} = −2^{31} = TMin_{32}$。

C 语言中，如果一个运算数是有符号的而另一个是无符号的，那么 C 语言会默认地将**有符号参数强制类型转换为无符号数**，并假设这两个数都是非负的来执行这个运算，便会导致有时候会出现一些奇怪的结果。

![](/images/CSAPP/Pasted%20image%2020250114224238.png)

以 -1<0U 为例，第二个运算数是无符号的，第一个运算数就会被转换为无符号数，因此表达式就等价于 4294967295U<0U（$T2U_w(-1) =UMax_w$），这个答案显然是错的。

#### 2.6. 扩展一个数字的位表示

**无符号数的零扩展**：只要简单地在表示的开头添加 0
**有符号补码数的符号扩展**：

![](/images/CSAPP/Pasted%20image%2020250115193034.png)

例如以下例子：

```C
short sx = -12345;          /* -12345 */
unsigned short usx = sx;    /*  53191 */
int x = sx;                 /* -12345 */
unsigned ux = usx;          /*  53191 */

printf("sx = %d:\t", sx);
show_bytes((byte_pointer) &sx, sizeof(short));
printf("usx = %u:\t", usx);
show_bytes((byte_pointer) &usx, sizeof(unsigned short));
printf("x = %d:\t", x);
show_bytes((byte_pointer) &x, sizeof(int));
printf("ux = %u:\t", ux);
show_bytes((byte_pointer) &ux, sizeof(unsigned));
```

在采用补码表示的 32 位大端法机器上运行这段代码时，打印出如下输出：

```text
sx  = -12345: cf c7
usx =  53191: cf c7
x   = -12345: ff ff cf c7
ux  =  53191: 00 00 cf c7
```

可以看到，当字长为 16 位时相同，在 32 位时字长不同，即**无符号补 0 有符号补 1**，即**扩位的时候应该添加的是符号位**。

另外一个例子是，位向量 [101]=-3，与位向量 [1101] 表示的值相同。

![](/images/CSAPP/Pasted%20image%2020250115193800.png)

#### 2.7. 截断数字

```C
int x = 53191;
short sx = (short) x;  /* -12345 */
int y = sx;            /* -12345 */
```

当把 x 强制类型转换为 short 时，32 位的 int 截断为了 16 位的 short int，即 00 00 cf c7 -> cf c7，sx 为 -12345；把它强制类型转换回 int 时，符号扩展把高 16 位置1，从而生成 -12345 的 32 位补码（ff ff cf c7）。

**截断无符号数**：

![](/images/CSAPP/Pasted%20image%2020250115201452.png)

**截断补码数**:

![](/images/CSAPP/Pasted%20image%2020250115201520.png)

还是以 x=53191 为例，当截断为无符号数时，由于 $2^{16}=65535 \geq x$，$x \mod 2^{16}=x$。当转换为补码时，$x'=53191-65536=-12345$。

#### 2.8. 关千有符号数与无符号数的建议

我们已经看到了许多无符号运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或者漏洞的方式。避免这类错误的一种方法就是**不使用无符号数**。

2002 年，从事 FreeBSD 开源操作系统项目的程序员意识到，他们对 getpeername 函数的实现存在安全漏洞。代码的简化版本如下：

```C
//void *memcpy(void *dest, void *src,  size_t n);

#define KSIZE 1024
char kbuf[KSIZE];

int copy_from_kernel(void *user_dest, int maxlen)
{
    int len = KSIZE < maxlen ? KSIZE : maxlen;
    memcpy(user_dest, kbuf, len);
    retn len;
}
```

函数copy_from_kernel是要将一些操作系统内核维护的数据复制到指定的用户可以访问的存储器区域。第八行的计算确保复制的字节数据不会超出源或者目标缓冲区可用的范围。不过，假如恶意对maxlen使用了负数值，那么最小值计算会把这个值赋给len，然后len会作为参数n被传递给memcpy。因为参数n是被声明为数据类型size_t。既然参数n是无符号的，那么memcpy会把它当作一个非常大的正整数，并且试图将这样多字节的数据从内核区域复制到用户的缓冲区。虽然复制这么多字节（至少231个）实际上不会完成，因为程序会遇到进程中非法地址的错误，但是程序还是能读到没有被授权的内核存储器区域。

要修正这个缺陷，只要将copy_from_kernel的参数maxlen声明为类型size_t，也就是与memcpy的参数n一致。同时，也应该将本地变量len和返回值声明为size_t。

### 3. 整数运算

#### 3.1. 无符号加法

两个非负整数 x 和 y 满足 $0 \leq x,y<2^w$，如果计算它们的和，就有一个范围 $0 \leq x+y \leq 2^{w+1}-2$，表示这个和可能需要 w+1 位，如下图所示：

![](/images/CSAPP/Pasted%20image%2020250115204735.png)

**数值溢出**：例如，x=9 和 y=12 的位向量分别为 [1001] 和 [1100]，和是 21，5 位的表示为 [10101]。但是如果丢弃最高位就得到 [0101]，也就是十进制值的 5 。这就和值 21 mod 16=5 一致。

**无符号数加法**：

![](/images/CSAPP/Pasted%20image%2020250115205031.png)

图 2-22 说明了公式 (2.11) 的这两种情况：

![](/images/CSAPP/Pasted%20image%2020250115205118.png)

2-23 展示了字长 w=4 的无符号加法函数的坐标图。

![](/images/CSAPP/Pasted%20image%2020250115205336.png)

**无符号数求反**：

![](/images/CSAPP/Pasted%20image%2020250115205658.png)

#### 3.2. 补码加法

![](/images/CSAPP/Pasted%20image%2020250115205815.png)

![](/images/CSAPP/Pasted%20image%2020250115205835.png)

当和 $x+y$ 超过 $TMax_w$ 时（情况 4), 发生**正溢出**。在这种情况下，截断的结果是从和中减去 $2^w$。当和 $x+y$ 小于 $TMin_w$ 时（情况 1), 发生**负溢出**。在这种情况下，截断的结果是从和中加上 $2^w$。

**补码加法**：

![](/images/CSAPP/Pasted%20image%2020250115210535.png)

对四种不同情况的分析如下：

![](/images/CSAPP/Pasted%20image%2020250115211058.png)

图 2-25 展示了一些 4 位补码加法的示例作为说明。每个示例的情况都被标号为对应于等式 (2. 13) 的推导过程中的情况。

![](/images/CSAPP/Pasted%20image%2020250115211207.png)

可以看到，运算数的范围为 -8~7 之间。当 $x+y<-8$ 时，补码加法就会负溢出，导致和增加了 16 。当 $-8 \leq x+y<8$ 时，加法就产生 x+y 。当  $x+y \geq 8$，加法就会正溢出，使得和减少16 。这三种情况中的每一种都形成了图中的一个斜面。

![](/images/CSAPP/Pasted%20image%2020250115211743.png)






### 4. 

### 5. 

### 6. 

---

## 参考引用

### 书籍出处

### 网页链接

- [补码编码、有符号无符号转化、字符扩展与截断 - yangbofun - 博客园](https://www.cnblogs.com/yb-blogs/p/13945559.html)
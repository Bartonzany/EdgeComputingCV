## 2 - 信息的表示和处理

---

### 1. 信息存储

- **字节（Byte）**：最小的可寻址的内存单位，一般为 8 位
- **虚拟内存（virtual memory）**：程序将内存视为一个非常大的字节数组
- **地址（address）**：内存的每个字节都由 一 个唯一的数字来标识
- **虚拟地址空间 (virtual address space)** ：所有可能地址的 集 合

#### 1.1. 十六进制表示法

一个字节由 8 位组成，在二进制表示法中，它的值域是 $00000000_2 \sim 11111111_2$。如果看成十进制整数，它的值域就是 $0_{10} \sim 255_{10}$。十六进制使用数字 '0'~'9' 以及字符 'A'~'F' 来表示 16  个可能的值。下图展示了 16 个十六进制数字对应的十进制值和二进制值。

![](/images/CSAPP/Pasted%20image%2020250111195718.png)

C 语言中，以 0x 或 0x 开头的数字常量是十六进制值。字符 'A'~'F' 既可以是大写 ，也可以是小写。例如，可以将数字 $FA1D37B_{16}$ 写作 0xFA1D37B，或者 0xfald37b, 甚至是大小写混合，比如，0xFa1D37b。进制的转换可以参照上表相对关系来完成。

**二进制转十六进制**可用以下转换关系实现：

$$
\begin{align*} 
x&=2^n \\
n&=i+4j, 0 \leq i \leq 3 \\
\end{align*}
$$
当 n 表示成 $i+4j$ 的形式，可以把 x 写成开头的十六进制数字为 1(i=0)、2(i=1)、4(i=2) 或者 8(i=3)，后面跟随着 j 个十六进制的 0。比如 $x=2048=2^{11}，n=11=3+ 4 \cdot 2$，从而得到十六进制表示 0x800。

**十进制转十六进制**需要使用乘法或者除法来处理。将一个十进制数字 x 转换为十六进制，可以反复用 16 除 x，得到一个商 q 和一个余数 r，也就是 $x=q \cdot 16+r$，用十六进制数字表示的 r 作为最低位数字。如下图十进制 314156 转十六进制，可以得到十六进制表示为 0x4CB2C

![](/images/CSAPP/Pasted%20image%2020250111201523.png)

**十六进制转换十进制数字**可以用相应的 16 的幂乘以每个十六进制数字。比如给定数字 0x7AF，计算对应的十进制值为 $7 \cdot 16^2+10^{16}+15=7 \cdot 256+10 \cdot 16+15=1792+160+15=1967$

#### 1.2. 字数据大小

每台计算机都有一个**字长 (word size)**，决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为 w 位的机器而言，虚拟地址的范围为 $0 \sim 2^w-1$。32 位字长限制虚拟地址空间为 4GB，64 位则为 16EB。**大多数 64 位机器也可以运行为 32 位机器编译的程序**，这在运行一些window系统软件非常常见。下图为不同字长系统对于 C 中的数据类型的大小。

![](/images/CSAPP/Pasted%20image%2020250111202742.png)

为了避免由于不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 int32 t 和 int64 七，它们分别为 4 个字节和 8 个字节。**程序员应该力图使他们的程序在不同的机器和编译器上可移植**。

#### 1.3. 寻址和字节顺序

在几乎所有的机器上，多字节对象都被存储为**连续的字节序列**，对象的地址为所使用**字节中最小的地址**。例如，假设一个类型为 int 的变量 x 的地址为 0x100，那么 x 的 4 个字节将被存储在内存的 0x100 、0x101、0x102 和 0x103 位置。

数据的寻址有大端法和小端法两种方式：

- **小端法 (little endian)** ：最低有效字节在最前面的方式
- **大端法 (big endian)** ：最高有效字节在最前面的 方式

假设变 量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567。地址范围 0x100 ~ 0x103 的字节顺序依赖于机器的类型：

![](/images/CSAPP/Pasted%20image%2020250111203534.png)

大多数 Intel PC机都只用小端模式，IBM 和 Oracle的大多数机器则是按大端模式。许多比较新的微处理器是双端法 (bi-endian)，也就是说可以把它们配置成作为大端或者小端的机器运行。最常见的两种操作系统 Android 和 IOS 只能运行小端模式。

在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准。

以下代码是在不同机器上的显示结果：

![](/images/CSAPP/Pasted%20image%2020250111204837.png)

![](/images/CSAPP/Pasted%20image%2020250111204856.png)

![](/images/CSAPP/Pasted%20image%2020250111204920.png)

#### 1.4. 表示字符串

十进制数字 x 的 ASCII 码正好是 0x3x，字母 'a'~'z' 的 ASCII 码为 0x61~0x7A

#### 1.5 表示代码

```C
int sum(int x, int y) {
	return x + y;
}
```

当在示例机器上编译时，生成如下字节表示的机器代码：

```text
Linux32    55 89 e5 8b 45 0c 03 45 08 c9 c3
Windows    55 89 e5 8b 45 0c 03 45 08 5d c3
Sun        81 c3 e0 08 90 02 00 09
Linux64    55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3
```

发现**指令编码是不同的**。不同的机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

#### 1.6 布尔代数简介

![](images/CSAPP/Pasted%20image%2020250111210326.png)

可以将上述 4 个布尔运算扩展到位向量的运算。举个例子，假设 w=4，参数 a= [0110] , b= [1100] 。那么 4 种运算 a&b、a l b、a ^ b 和 ~b 分别得到以下结果：

![](/images/CSAPP/Pasted%20image%2020250111210459.png)

位向量一个很有用的应用就是表示有限集合，可以用位向量 $[a_{w−1}, ..., a1, a0]$ 编码任何子集 $A \subseteq \{0,1,...,w-1\}$。位向量并集的例子：a=[01101001] 表示{0，3，5，6}，b=[01010101] 表示{0，2，4，6}。最终二者并集 a&b =[01000001]={0，6}。注意是从右往左数，1 为相对应的位置。位向量多用于掩码的表示。

#### 1.7. C 语言中的移位运算

即向左或者向右移动位模式，下表给出了对一个 8 位参数 x 的两个不同的值做不同的移
位操作得到的结果：

![](/images/CSAPP/Pasted%20image%2020250111211849.png)

可以看到，逻辑运算是填充 0，算术运算是填充 1。C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。

### 2. 整数表示

### 3. 

### 4. 

### 5. 

### 6. 

---

## 参考引用

### 书籍出处

### 网页链接


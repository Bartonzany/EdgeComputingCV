## 2 - 信息的表示和处理

---

### 1. 信息存储

- **字节（Byte）**：最小的可寻址的内存单位，一般为 8 位
- **虚拟内存（virtual memory）**：程序将内存视为一个非常大的字节数组
- **地址（address）**：内存的每个字节都由一个唯一的数字来标识
- **虚拟地址空间 (virtual address space)** ：所有可能地址的集合

#### 1.1. 十六进制表示法

一个字节由 8 位组成，在二进制表示法中，它的值域是 $00000000_2 \sim 11111111_2$。如果看成十进制整数，它的值域就是 $0_{10} \sim 255_{10}$。十六进制使用数字 `'0'~'9'` 以及字符 `'A'~'F'` 来表示 16  个可能的值。下图展示了 16 个十六进制数字对应的十进制值和二进制值。

![](/images/CSAPP/Pasted%20image%2020250111195718.png)

C 语言中，以 0x 或 0x 开头的数字常量是十六进制值。字符 'A'~'F' 既可以是大写 ，也可以是小写。例如，可以将数字 $FA1D37B_{16}$ 写作 0xFA1D37B，或者 0xfald37b, 甚至是大小写混合，比如，0xFa1D37b。进制的转换可以参照上表相对关系来完成。

**二进制转十六进制**可用以下转换关系实现：

$$
\begin{align*} 
x&=2^n \\
n&=i+4j, 0 \leq i \leq 3 \\
\end{align*}
$$

当 n 表示成 $i+4j$ 的形式，可以把 x 写成开头的十六进制数字为 1(i=0)、2(i=1)、4(i=2) 或者 8(i=3)，后面跟随着 j 个十六进制的 0。比如 $x=2048=2^{11}，n=11=3+ 4 \cdot 2$，从而得到十六进制表示 0x800。

**十进制转十六进制**需要使用乘法或者除法来处理。将一个十进制数字 x 转换为十六进制，可以反复用 16 除 x，得到一个商 q 和一个余数 r，也就是 $x=q \cdot 16+r$，用十六进制数字表示的 r 作为最低位数字。如下图十进制 314156 转十六进制，可以得到十六进制表示为 0x4CB2C

![](/images/CSAPP/Pasted%20image%2020250111201523.png)

**十六进制转换十进制数字**可以用相应的 16 的幂乘以每个十六进制数字。比如给定数字 0x7AF，计算对应的十进制值为 $7 \cdot 16^2+10^{16}+15=7 \cdot 256+10 \cdot 16+15=1792+160+15=1967$

#### 1.2. 字数据大小

每台计算机都有一个**字长 (word size)**，决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为 w 位的机器而言，虚拟地址的范围为 $0 \sim 2^w-1$。32 位字长限制虚拟地址空间为 4GB，64 位则为 16EB。**大多数 64 位机器也可以运行为 32 位机器编译的程序**，这在运行一些window系统软件非常常见。下图为不同字长系统对于 C 中的数据类型的大小。

![](/images/CSAPP/Pasted%20image%2020250111202742.png)

为了避免由于不同编译器设置带来的奇怪行为，ISO C99 引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型 int32 t 和 int64 七，它们分别为 4 个字节和 8 个字节。**程序员应该力图使他们的程序在不同的机器和编译器上可移植**。

#### 1.3. 寻址和字节顺序

在几乎所有的机器上，多字节对象都被存储为**连续的字节序列**，对象的地址为所使用**字节中最小的地址**。例如，假设一个类型为 int 的变量 x 的地址为 0x100，那么 x 的 4 个字节将被存储在内存的 0x100 、0x101、0x102 和 0x103 位置。

数据的寻址有大端法和小端法两种方式：

- **小端法 (little endian)** ：最低有效字节在最前面的方式
- **大端法 (big endian)** ：最高有效字节在最前面的 方式

假设变 量 x 的类型为 int，位于地址 0x100 处，它的十六进制值为 0x01234567。地址范围 0x100 ~ 0x103 的字节顺序依赖于机器的类型：

![](/images/CSAPP/Pasted%20image%2020250111203534.png)

大多数 Intel PC机都只用小端模式，IBM 和 Oracle的大多数机器则是按大端模式。许多比较新的微处理器是双端法 (bi-endian)，也就是说可以把它们配置成作为大端或者小端的机器运行。最常见的两种操作系统 Android 和 IOS 只能运行小端模式。

在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准。

以下代码是在不同机器上的显示结果：

![](/images/CSAPP/Pasted%20image%2020250111204837.png)

![](/images/CSAPP/Pasted%20image%2020250111204856.png)

![](/images/CSAPP/Pasted%20image%2020250111204920.png)

#### 1.4. 表示字符串

十进制数字 x 的 ASCII 码正好是 0x3x，字母 `'a'~'z'` 的 ASCII 码为 0x61~0x7A

#### 1.5 表示代码

```C
int sum(int x, int y) {
	return x + y;
}
```

当在示例机器上编译时，生成如下字节表示的机器代码：

```text
Linux32    55 89 e5 8b 45 0c 03 45 08 c9 c3
Windows    55 89 e5 8b 45 0c 03 45 08 5d c3
Sun        81 c3 e0 08 90 02 00 09
Linux64    55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3
```

发现**指令编码是不同的**。不同的机器类型使用不同的且不兼容的指令和编码方式，即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

#### 1.6 布尔代数简介

![](/images/CSAPP/Pasted%20image%2020250111210326.png)

可以将上述 4 个布尔运算扩展到位向量的运算。举个例子，假设 w=4，参数 a= [0110] , b= [1100] 。那么 4 种运算 a&b、a l b、a ^ b 和 ~b 分别得到以下结果：

![](/images/CSAPP/Pasted%20image%2020250111210459.png)

位向量一个很有用的应用就是表示有限集合，可以用位向量 $[a_{w−1}, ..., a1, a0]$ 编码任何子集 $A \subseteq \{0,1,...,w-1\}$。位向量并集的例子：a=[01101001] 表示{0，3，5，6}，b=[01010101] 表示{0，2，4，6}。最终二者并集 a&b =[01000001]={0，6}。注意是从右往左数，1 为相对应的位置。位向量多用于掩码的表示。

#### 1.7. C 语言中的移位运算

即向左或者向右移动位模式，下表给出了对一个 8 位参数 x 的两个不同的值做不同的移
位操作得到的结果：

![](/images/CSAPP/Pasted%20image%2020250111211849.png)

可以看到，逻辑运算是填充 0，算术运算是填充 1。C 语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。

### 2. 整数表示

#### 2.1. 整型数据类型

下图是 32 位和 64 位上 C 的整数类型取值范围。唯一一个与机器相关的取值范围是 long
，大多数 64 位机器使用 8 个字节的表示，比 32 位机器上使用的 4 个字节的表示的取值
范围大很多。

![](/images/CSAPP/Pasted%20image%2020250114213911.png)

![](/images/CSAPP/Pasted%20image%2020250114213932.png)

#### 2.2. 无符号数的编码

![](/images/CSAPP/Pasted%20image%2020250114214348.png)

![](/images/CSAPP/Pasted%20image%2020250114214410.png)

![](/images/CSAPP/Pasted%20image%2020250114214537.png)

#### 2.3. 补码编码

![](/images/CSAPP/Pasted%20image%2020250114214625.png)

![](/images/CSAPP/Pasted%20image%2020250114214653.png)

![](/images/CSAPP/Pasted%20image%2020250114214714.png)

在这个图中，用向左指的条表示符号位具有负权重。一个位向量相关联的数值是由向左指和向右指的长度相加决定。

![](/images/CSAPP/Pasted%20image%2020250114215148.png)

上图是用补码表示的整数取值范围，C 语言也一般用补码形式来表示有符号整数。C 库中的文件＜limits.h> 定义了一组常量，来限定编译器运行的机器不同整型数据类型的取值范围。比如，它定义了常量 **INT_MAX** 、**INT_MIN** 和 **UINT_MAX**, 它们描述了有符号和无符号整数的范围。

为了更好地理解补码表示，考虑 下面的代码：

```C
short x = 12345;
short mx = -x;

show_bytes((byte_pointer) &x, sizeof(short));
show_bytes((byte_pointer) &mx, sizeof(short));
```

当在大端法机器上运行时，这段代码的输出为 30 39 和 cf c7，指明 x 的十六进制表示为 0x3039，而 mx 的十六进制表示为 0xCFC7。将它们展开为二进制，得到 x 的为 [0011000000111001]，而 mx 的位模式为 [1100111111000111] 。如图所示：

![](/images/CSAPP/Pasted%20image%2020250114221050.png)

**反码**：最高有效位的权是 $-(2^{w-1}-1)$，其他和补码一致

![](/images/CSAPP/Pasted%20image%2020250115195726.png)

**原码**：最高有效位是符号位，用来确定剩下的位应该取负权还是正权：

![](/images/CSAPP/Pasted%20image%2020250115195759.png)

从公式同样可以看出，当最高位是0时，反码和原码解释得到的值是一样的，

- 0b0000 0000 ---> 原码表示0，反码也是表示0.

但当最高位是1时，

- 0b1000 0000 ---> 原码表示0，反码表示-127

可以看出，使用原码表示 0 的值不一致。

#### 2.4. 有符号数和无符号数之间的转换

**补码转换为无符号数**：

![](/images/CSAPP/Pasted%20image%2020250114221526.png)

比如，$T2U_{16}(-12345)=-12345+2^{16}=53191$。另外一个例子是 $w=4$ 时，补码最高有效位是符号位，用带向左箭头的条表示；无符号数最高有效位是正权重，用带向右的箭头的条表示。从补码变为无符号数，最高有效位权重从 -8 变为 +8。因此，补码表示的负数如果看成无符号数，值会增加 $2^4=16$，因而 -5 变成了 +11，而 -1 变成 +15。 

![](/images/CSAPP/Pasted%20image%2020250114222358.png)

下图进一步图示了从补码到无符号数的转换：

![](/images/CSAPP/Pasted%20image%2020250114222446.png)

**无符号数转换为补码**：

![](/images/CSAPP/Pasted%20image%2020250114222506.png)

![](/images/CSAPP/Pasted%20image%2020250114222704.png)

#### 2.5. C 语言中的有符号数与无符号数

因为大部分机器使用补码表示无符号数和有符号数，所以套用补码转换为无符号数（**有符号数转换为无符号数**）和无符号数转换为补码（**无符号数转换为有符号数**）。例如以下例子：

```C
int x = -1;
unsigned u = 2147483648; /* 2 to the 31st */

printf("x = %u = %d\n", x, x);
printf("u = %u = %d\n", u, u);
```

输出如下：

```text
x = 4294967295 = -1
u = 2147483648 = -2147483648
```

printf 首先将这个字当作一个无符号数输出，然后把它当作一个有符号数输出。使用了  $T2U_{32}(−1) = UMax_{32} = 2^{32} − 1$ 和 $U2T_{32}(2^{31}) = 2^{31} − 2^{32} = −2^{31} = TMin_{32}$。

C 语言中，如果一个运算数是有符号的而另一个是无符号的，那么 C 语言会默认地将**有符号参数强制类型转换为无符号数**，并假设这两个数都是非负的来执行这个运算，便会导致有时候会出现一些奇怪的结果。

![](/images/CSAPP/Pasted%20image%2020250114224238.png)

以 -1<0U 为例，第二个运算数是无符号的，第一个运算数就会被转换为无符号数，因此表达式就等价于 4294967295U<0U（$T2U_w(-1) =UMax_w$），这个答案显然是错的。

#### 2.6. 扩展一个数字的位表示

**无符号数的零扩展**：只要简单地在表示的开头添加 0
**有符号补码数的符号扩展**：

![](/images/CSAPP/Pasted%20image%2020250115193034.png)

例如以下例子：

```C
short sx = -12345;          /* -12345 */
unsigned short usx = sx;    /*  53191 */
int x = sx;                 /* -12345 */
unsigned ux = usx;          /*  53191 */

printf("sx = %d:\t", sx);
show_bytes((byte_pointer) &sx, sizeof(short));
printf("usx = %u:\t", usx);
show_bytes((byte_pointer) &usx, sizeof(unsigned short));
printf("x = %d:\t", x);
show_bytes((byte_pointer) &x, sizeof(int));
printf("ux = %u:\t", ux);
show_bytes((byte_pointer) &ux, sizeof(unsigned));
```

在采用补码表示的 32 位大端法机器上运行这段代码时，打印出如下输出：

```text
sx  = -12345: cf c7
usx =  53191: cf c7
x   = -12345: ff ff cf c7
ux  =  53191: 00 00 cf c7
```

可以看到，当字长为 16 位时相同，在 32 位时字长不同，即**无符号补 0 有符号补 1**，即**扩位的时候应该添加的是符号位**。

另外一个例子是，位向量 [101]=-3，与位向量 [1101] 表示的值相同。

![](/images/CSAPP/Pasted%20image%2020250115193800.png)

#### 2.7. 截断数字

```C
int x = 53191;
short sx = (short) x;  /* -12345 */
int y = sx;            /* -12345 */
```

当把 x 强制类型转换为 short 时，32 位的 int 截断为了 16 位的 short int，即 00 00 cf c7 -> cf c7，sx 为 -12345；把它强制类型转换回 int 时，符号扩展把高 16 位置1，从而生成 -12345 的 32 位补码（ff ff cf c7）。

**截断无符号数**：

![](/images/CSAPP/Pasted%20image%2020250115201452.png)

**截断补码数**:

![](/images/CSAPP/Pasted%20image%2020250115201520.png)

还是以 x=53191 为例，当截断为无符号数时，由于 $2^{16}=65535 \geq x$，$x \mod 2^{16}=x$。当转换为补码时，$x'=53191-65536=-12345$。

#### 2.8. 关千有符号数与无符号数的建议

我们已经看到了许多无符号运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或者漏洞的方式。避免这类错误的一种方法就是**不使用无符号数**。

2002 年，从事 FreeBSD 开源操作系统项目的程序员意识到，他们对 getpeername 函数的实现存在安全漏洞。代码的简化版本如下：

```C
//void *memcpy(void *dest, void *src,  size_t n);

#define KSIZE 1024
char kbuf[KSIZE];

int copy_from_kernel(void *user_dest, int maxlen)
{
    int len = KSIZE < maxlen ? KSIZE : maxlen;
    memcpy(user_dest, kbuf, len);
    retn len;
}
```

函数copy_from_kernel是要将一些操作系统内核维护的数据复制到指定的用户可以访问的存储器区域。第八行的计算确保复制的字节数据不会超出源或者目标缓冲区可用的范围。不过，假如恶意对maxlen使用了负数值，那么最小值计算会把这个值赋给len，然后len会作为参数n被传递给memcpy。因为参数n是被声明为数据类型size_t。既然参数n是无符号的，那么memcpy会把它当作一个非常大的正整数，并且试图将这样多字节的数据从内核区域复制到用户的缓冲区。虽然复制这么多字节（至少231个）实际上不会完成，因为程序会遇到进程中非法地址的错误，但是程序还是能读到没有被授权的内核存储器区域。

要修正这个缺陷，只要将copy_from_kernel的参数maxlen声明为类型size_t，也就是与memcpy的参数n一致。同时，也应该将本地变量len和返回值声明为size_t。

### 3. 整数运算

#### 3.1. 无符号加法

两个非负整数 x 和 y 满足 $0 \leq x,y<2^w$，如果计算它们的和，就有一个范围 $0 \leq x+y \leq 2^{w+1}-2$，表示这个和可能需要 w+1 位，如下图所示：

![](/images/CSAPP/Pasted%20image%2020250115204735.png)

**数值溢出**：例如，x=9 和 y=12 的位向量分别为 [1001] 和 [1100]，和是 21，5 位的表示为 [10101]。但是如果丢弃最高位就得到 [0101]，也就是十进制值的 5 。这就和值 21 mod 16=5 一致。

**无符号数加法**：

![](/images/CSAPP/Pasted%20image%2020250115205031.png)

图 2-22 说明了公式 (2.11) 的这两种情况：

![](/images/CSAPP/Pasted%20image%2020250115205118.png)

2-23 展示了字长 w=4 的无符号加法函数的坐标图。

![](/images/CSAPP/Pasted%20image%2020250115205336.png)

**无符号数求反**：

![](/images/CSAPP/Pasted%20image%2020250115205658.png)

#### 3.2. 补码加法

![](/images/CSAPP/Pasted%20image%2020250115205815.png)

![](/images/CSAPP/Pasted%20image%2020250115205835.png)

当和 $x+y$ 超过 $TMax_w$ 时（情况 4), 发生**正溢出**。在这种情况下，截断的结果是从和中减去 $2^w$。当和 $x+y$ 小于 $TMin_w$ 时（情况 1), 发生**负溢出**。在这种情况下，截断的结果是从和中加上 $2^w$。

**补码加法**：

![](/images/CSAPP/Pasted%20image%2020250115210535.png)

对四种不同情况的分析如下：

![](/images/CSAPP/Pasted%20image%2020250115211058.png)

图 2-25 展示了一些 4 位补码加法的示例作为说明。每个示例的情况都被标号为对应于等式 (2. 13) 的推导过程中的情况。

![](/images/CSAPP/Pasted%20image%2020250115211207.png)

可以看到，运算数的范围为 -8~7 之间。当 $x+y<-8$ 时，补码加法就会负溢出，导致和增加了 16 。当 $-8 \leq x+y<8$ 时，加法就产生 x+y 。当  $x+y \geq 8$，加法就会正溢出，使得和减少16 。这三种情况中的每一种都形成了图中的一个斜面。

![](/images/CSAPP/Pasted%20image%2020250115211743.png)

#### 3.3. 补码的非

**补码的非**：

![](/images/CSAPP/Pasted%20image%2020250115215019.png)

补码取反另一种更方便的方式是，**最右边的 1 的位置为 k，对位 K 左边的所有位取反**：

![](/images/CSAPP/Pasted%20image%2020250115215237.png)

#### 3.4 无符号乘法

![](/images/CSAPP/Pasted%20image%2020250115215339.png)

#### 3.5. 补码乘法

![](/images/CSAPP/Pasted%20image%2020250115215627.png)

![](/images/CSAPP/Pasted%20image%2020250115215658.png)

**XOR 库中安全漏洞**

2002 年，人们发现 Sun Microsystems 公司提供的实现 XDR 库的代码有安全漏洞，造成这个安全漏洞的原因是程序会在毫无察觉的情况下产生乘法溢出。

```c
void* copy_elements(void *ele_src[], int ele_cnt, size_t ele_size) {
	void *result = malloc(ele_cnt * ele_size);
	if (result == NULL)
		/* malloc failed */
		return NULL;
	void *next = result;
	int i;
	for (i = 0; i < ele_cnt; i++) {
		/* Copy object i to destination */
		memcpy(next, ele_src[i], ele_size);
		/* Move pointer to next memory region */
		next += ele_size;
	}
	return result;
}
```

函数 copy_elements 设计用来将 ele_cnt 个数据结构复制到 malloc 函数分配的缓冲区中，每个数据结构包含 ele_size 个字节。若参数 ele_cnt 等于 1048577($2^{20}+1$)、ele_size 等于 4096($2^{12}$) 来调用这个函数。然后 malloc 函数的乘法会溢出，导致只会分配 4096 个字节，而不是装下这些数据所需要的 4294971392 个宇节。for 循环会试图复制所有的字节，超越已分配的缓冲区的界限，因而破坏了其他的数据结构，导致程序崩溃或者行为异常。

#### 3.6. 乘以常数

以往，在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然
而其他整数运算（例如加法、减法、位级运算和移位）只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，**用移位和加法运算的组合来代替乘以常数因子的乘法**。

**乘以 2 的幂**：

![](/images/CSAPP/Pasted%20image%2020250116114550.png)

比如，当 w=4 时，11 可以被表示为 [1011]。k=2 时将其左移得到 6 位向量 [101100]，即可编码为无符号数 $11 \cdot 4=44$。

**与 2 的幂相乘的无符号乘法**：

![](/images/CSAPP/Pasted%20image%2020250116114810.png)

**与 2 的幂相乘的补码乘法**：

![](/images/CSAPP/Pasted%20image%2020250116114855.png)

注意，无论是无符号运算还是补码运算，乘以 2 的幂都可能会**导致溢出**。例如，将 [1011] 左移两位得到 [101100]。将这个值截断为 4 位得到 [1100]（12=44 mod 16）。

**与 k相乘**：

由于整数乘法比移位和加法的代价要大得多，许多 C 语言编译器试图以**移位、加法和减法的组合**来消除很多整数乘以常数的情况。例如，一个程序包含表达式 `x*14`。利用 $14=2^3+2^2+2^1$，编译器会将乘法重写为 $(x<<3)+(x<<2)+(x<<1)$，将一个乘法替换为三个移位和两个加法。

归纳一下，对于某个常数 K 的表达式 $x*K$，编译器会将 K 的二进制表示表达为一组 0 和 1 交替的序列：

$$
[(0 . . . 0) (1 . . . 1) (0 . . . 0) . . . (1 . . . 1)]
$$

例如，14 可以写成 [(0…0)(111)(0)]。则对应有 1 的位进行左移处理并相加就能计算出  $x*K$。

#### 3.7. 除以 2 的幂

在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的时钟周期。除以 2 的幂也可以用移位运算来实现，只不过用的是**右移**，而不是左移。整数除法会舍入到零，向上取整如 $\lfloor 3.14 \rfloor=3,\lfloor -3.14 \rfloor=-4,\lfloor 3 \rfloor=3$，向下取整如 $\lceil 3.14 \rceil=4,\lceil -3.14 \rceil=-3,\lceil 3 \rceil=3$。对于 $x \geq 0,y>0$，结果是 $\lfloor x/y \rfloor$。而对于 $x<0,y>0$，结果是 $\lceil x/y \rceil$。即向下舍入一个正值，而向上舍入一个负值。

**除以 2 的幂的无符号除法**：

![](/images/CSAPP/Pasted%20image%2020250116120958.png)

如下图所示，给出了在 12340 的 16 位表示上执行逻辑右移的结果，以及对它执行除以 1、2、16 和 256 的结果。这些示例说明，移位总是舍入到零的结果，这一点与整数除法的规则一样 。

![](/images/CSAPP/Pasted%20image%2020250116121300.png)

**除以 2 的幂的补码除法，向下取整**：

![](/images/CSAPP/Pasted%20image%2020250116121546.png)

下图则是负数的例子

![](/images/CSAPP/Pasted%20image%2020250116121655.png)

**除以 2 的幂的补码除法，向上取整**：

![](/images/CSAPP/Pasted%20image%2020250116122109.png)

 下图说明了在执行算术右移之前加上一个适当的偏置量的影响。即对于整数 x 和 y(y>0)，$\lfloor x/y \rfloor=\lceil (x+y-1)/y \rceil$。

![](/images/CSAPP/Pasted%20image%2020250116121740.png)

同乘法不同，**不能用除以 2 的幂的除法来表示除以任意常数 K 的除法**。

#### 3.8. 关千整数运算的最后思考

计算机执行的“整数”运算实际上是一种**模运算**形式，且运算可能溢出。补码既能表示负数也能表示正数，可以用位运算实现加法、减法、乘法，甚至除法。

### 4. 浮点数

#### 4.1. 二进制小数

**十进制数表示法**如下所示：

$$
d_md_{m-1}\cdots d_1d_0.d_{-1}d_{-2}\cdots d_{-n} 
$$

用公式表达如下：

$$
d=\sum_{i=-n}^m10^i \times d_i
$$

例如，12.34 表示为 $1\times10^1+2\times10^0+3\times10^{-1}+4\times10^{-2}=12\frac{34}{100}$。

**二进制数表示法**如下所示：

$$
b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n} 
$$

用公式表达如下：


$$
b=\sum_{i=-n}^m2^i \times b_i
$$

例如，101.11 表示为 $1\times2^2+0\times2^1+1\times2^{-1}+1\times2^{-2}=4+0+1+\frac12+\frac14=5\frac34$。

![](/images/CSAPP/Pasted%20image%2020250117200646.png)

可以看出，**二进制小数点向左移动一位相当于这个数除以 2**。例如，101.11 表示 $5\frac34$，而 10.111 表示数 $2+0+\frac12+\frac14+\frac18=2\frac78$。类似，二进制小数点向右移动一位相当于将该数乘 2。例如 1011.1 表示数 $8+0+2+1+\frac12=11\frac12$。此外，如果数的位数不够，那么十进制/二进制表示法都不能很好的表达 $\frac13$ 和 $\frac57$。例如 $\frac15$ 可以用十进制 0.2 精确表示，但不能精确用二进制精确表示，只能通过增加二进制表示长度提高表示的精度：

![](/images/CSAPP/Pasted%20image%2020250117201623.png)

#### 4.2. IEEE 浮点表示

IEEE 浮点标准用 $V=(-1)^s\times M\times2^E$ 的形式表示一个数：

- **符号(sign)**：s 决定数是正数还是负数
- **尾数(significand)**：M是一个二进制小数，范围是 $1 \sim 2-\epsilon$，或者是 $0 \sim 1-\epsilon$。
- **阶码(exponent)**：E 的作用是对浮点数加权，这个权重是 2 的 E 次幂（可能是负数）。阶码=阶码真值+$2^{E-1}$

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

1. 一个单独的符号位 s 直接编码符号 s
2. k 位的阶码字段 $exp=e_{k-1}...e_1e_0$ 编码阶码 E 。
3. n 位小数字段 $frac=f_{n-1}...f_1f_0$ 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0

图 2-32 给出了将这三个字段装进字中两种最常见的格式。在单精度浮点格式 （C 语言中的 float）中，s、exp 和 frac 字段分别为 1 位、k = 8 位和 n=23 位，得到一个 32 位的表示。在双精度浮点格式 (C 语言中的 double) 中，s、exp 和 frac 字段分别为 1 位、k=11 位和 n=52 位，得到一个 64 位的表示。

![](/images/CSAPP/Pasted%20image%2020250117202730.png)

根据 exp 的值，被编码的值可以分成三种不同的情况：

- **规格化的值**：当 exp 的位模式既不全为 0( 数值 0)，也不全为 1 (单精度数值为 255, 双精度数值为 2047) 时，都属于这类情况。
- **非规格化的值**：当阶码域为全 0 时。非规格化数有两个用途。首先，它们提供了一种表示数值 0 的方法。注意，当符号位是 0，阶码位全为 0，而小数域也全为 0 时，表示 -0.0；当符号位是 1，阶码位全为 0，而小数域也全为 0 时，表示 +0.0。+0.0 和 -0.0 在某些方面被认为是不同的，而在其他方面是相同的。另外一个功能是表示那些非常接近于 0.0 的数。
- **特殊值**：阶码全为 1， 当小数域全为 0 时，得到的值表示无穷大，s=0 为 $+\infty$，s=1 为 $-\infty$。 把两个非常大的数相乘，或者除以零时，无穷能够表示溢出的结果。当小数域为非零时，结果值被称为 NaN，即**不是一个数(Not a Number)**。一些运算的结果不能是实数或无穷，就会返回这样的 NaN 值，如 $\sqrt-1$。

![](/images/CSAPP/Pasted%20image%2020250117203849.png)

#### 4.3 数字示例

图 2-34 展示了一组数值，最大数量值的规格化数是 $\pm14$，非规格化数聚集在 0 的附近，两个零是特殊的非规格化数。可以观察到，那些可表示的数并不是均匀分布的——越靠近原点处它们越稠密。

![](/images/CSAPP/Pasted%20image%2020250117204222.png)

图 2-35 展示了假定的 8 位浮点格式的示例，其中有 k=4 的阶码位和 n=3 的小数位，偏置量是 $2^{4-1}-1=7$。

![](/images/CSAPP/Pasted%20image%2020250117211312.png)

- 对于非规格化数，$E=1-7=-6$，小数范围是 $0\sim \frac78$;
- 对于规格化数，$E=1-7=-6$，小数范围是 $0\sim \frac78$，然而尾数范围需要在小数范围上加 1；

图 2-36 展示了一些重要的单精度和双精度浮点数的表示和数字值，可以看出一些非负浮点数的属性：

![](/images/CSAPP/Pasted%20image%2020250117212003.png)

- 最小的正非规格化值的位表示，是由最低有效位为 1 而其他所有位为 0 构成的；
- 最大的非规格化值的位模式是由全为 0 的阶码字段和全为 1 的小数字段组成的；
- 最小的正规格化值的位模式的阶码字段的最低有效位为 1，其他位全为 0；
- 值 1.0 的位表示的阶码字段除了最高有效位等于 1 以外，其他位都等于 0；
- 最大的规格化值的位表示的符号位为 0，阶码的最低有效位等于 0，其他位等于 1。

例如，12345= [11000000111001]，通过将二进制小数点左移 13 位，得到 $1.1000000111001\times 2^{13}$，丢弃开头的 1 并且在末尾增加 10 个 0，构造小数字段得到  [10000001110010000000000]。 用 13 加上偏置量 127 得到阶码字段 140, 其二进制表示为 [10001100]。加上符号位 0 就得到 IEEE 形式 [01000110010000001110010000000000]。整数值 12345 (0x3039) 和单精度浮点值 12345.0(0x4640E400) 在位级表示上有下列关系：

![](/images/CSAPP/Pasted%20image%2020250117213135.png)

现在可以看到，相关的区域对应于整数的低位，刚好在等于 1 的最高有效位之前停止（这个位就是隐含的开头的位 1)，和浮点表示的小数部分的高位是相匹配的。

#### 4.4. 舍入

因为表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算，即使用一种方法找到**最接近的匹配值**。图 2-37 举例说明了四种舍入方式。向偶数舍入 (round-to-even) , 也被称为向最接近的值舍入 (round-to-nearest) , 是默认的方式。向零舍入方式把正数向下舍入，把负数向上舍入。向下舍入方式把正数和负数都向下舍入，向上舍入方式把正数和负数都向上舍入。

![](/images/CSAPP/Pasted%20image%2020250117213524.png)

#### 4.5. C 语言中的浮点数

float 和 double 关键字。当程序文件中出现下列句子时，GNU 编译器 GCC 会定义程序常数 INFINITY( 表示$+\infty$)和 NAN(表示NaN)。

```C
#define _GNU_SOURCE 1
#include <math.h>
```

当在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式
的原则如下（假设 int 是 32 位的）：

- 从 int 转换成 float，数字不会溢出，但是可能被舍入；
- 从 int 或 float 转换成 double,因为 double 有更大的范围（也就是可表示值的范围），也有更高的精度（也就是有效位数），所以能够保留精确的数值;
- 从 double 转换成 float，因为范围要小一些，所以值可能溢出成 $+\infty$ 或 $-\infty$。另外，由于精确度较小，它还可能被舍入；
- 从 float 或者 double 转换成 int，值将会向零舍入。例如，1.999 将被转换成1，而 -1.999 将被转换成 -1。进一步来说，值可能会溢出。

### 5. 小结

计算机将信息编码为位（比特），通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定。

C 语言的设计可以包容多种不同字长和数字编码的实现。64 位字长的机器逐渐普及，并正在取代统治市场长达 30 多年的 32 位机器。由千 64 位机器也可以运行为 32 位机器编译的程序，我们的重点就放在区分 32 位和 64 位程序，而不是机器本身。64 位程序的优势是可以突破 32 位程序具有的 4GB 地址限制。

大多数机器对整数使用补码编码，而对浮点数使用 IEEE 标准 754 编码。在位级上理解这些编码，并且理解算术运算的数学特性，对千想使编写的程序能在全部数值范围上正确运算的程序员来说，是很重要的。

在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数 C 语言实现遵循的原则是底层的位模式不变。在补码机器上，对于一个 w 位的值，这种行为是由函数 $T2U_w$ 和 $U2T_w$ 来描述的。C 语言隐式的强制类型转换会出现许多程序员无法预计的结果，常常导致程序错误。

由于编码的长度有限，与传统整数和实数运算相比，计算机运算具有非常不同的属性。当超出表示范围时，有限长度能够引起数值溢出。当浮点数非常接近于 0.0，从而转换成零时，也会下溢。

和大多数其他程序语言一样，C 语言实现的有限整数运算和真实的整数运算相比，有一些特殊的属性。例如，由于溢出，表达式 `x*x` 能够得出负数。但是，无符号数和补码的运算都满足整数运算的许多其他属性，包括结合律、交换律和分配律。这就允许编译器做很多的优化。例如，用 (x<<3)-x 取代表达式 `7*x` 时，我们就利用了结合律、交换律和分配律的属性，还利用了移位和乘以 2 的幂之间的关系。

我们已经看到了几种使用位级运算和算术运算组合的聪明方法。例如，使用补码运算，~x+1 等价于 -x 。另外一个例子，假设我们想要一个形如 [0, …, 0, 1, …, 1] 的位模式，由 w-k 个 0 后面紧跟着 k 个 1 组成。这些位模式有助于掩码运算。这种模式能够通过 C 表达式 (1<<k) -1 生成，利用的是这样一个属性，即我们想要的位模式的数值为 $2^k-1$ 。例如，表达式 (1<<8)-1 将产生位模式 0xFF。

浮点表示通过将数字编码为 $x \times 2^y$ 的形式来近似地表示实数。最常见的浮点表示方式是由 IEEE 标准 754 定义的。它提供了几种不同的精度，最常见的是单精度 (32 位）和双精度 (64 位）。IEEE 浮点也能够表示特殊值 $+\infty$、$-\infty$ 和 $NaN$。

必须非常小心地使用浮点运算，因为浮点运算只有有限的范围和精度，而且并不遵守普遍的算术属性，比如结合性。




---

## 参考引用

### 书籍出处

- [深入理解计算机系统 (Randal E. Bryant, David R. O’Hallaron)](asset/Computer%20Network/深入理解计算机系统%20(Randal%20E.%20Bryant,%20David%20R.%20O’Hallaron).pdf)
- [Computer.Systems.A.Programmers.Perspective.3rd.Global.Edition.2015.7](asset/Computer%20Network/Computer.Systems.A.Programmers.Perspective.3rd.Global.Edition.2015.7.pdf)

### 网页链接

- [补码编码、有符号无符号转化、字符扩展与截断 - yangbofun - 博客园](https://www.cnblogs.com/yb-blogs/p/13945559.html)
- [IEEE浮点数向偶数舍 - 江水为竭 - 博客园](https://www.cnblogs.com/Az1r/p/16712794.html)